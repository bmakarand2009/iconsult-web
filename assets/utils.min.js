/*! iconsult 12-03-2014 version: 1.0.0 
 author: https://twitter.com/MakBkar */

/*global angular:true, browser:true */
/**
* @license HTTP Auth Interceptor Module for AngularJS
* (c) 2012 Witold Szczerba
* License: MIT
*/
(function() {
    "use strict";
    angular.module("http-auth-interceptor", [ "http-auth-interceptor-buffer" ]).factory("authService", [ "$rootScope", "httpBuffer", function($rootScope, httpBuffer) {
        return {
            /**
* Call this function to indicate that authentication was successfull and trigger a
* retry of all deferred requests.
* @param data an optional argument to pass on to $broadcast which may be useful for
* example if you need to pass through details of the user that was logged in
*/
            loginConfirmed: function(data, configUpdater) {
                var updater = configUpdater || function(config) {
                    return config;
                };
                $rootScope.$broadcast("event:auth-loginConfirmed", data);
                httpBuffer.retryAll(updater);
            },
            /**
* Call this function to indicate that authentication should not proceed.
* All deferred requests will be abandoned or rejected (if reason is provided).
* @param data an optional argument to pass on to $broadcast.
* @param reason if provided, the requests are rejected; abandoned otherwise.
*/
            loginCancelled: function(data, reason) {
                httpBuffer.rejectAll(reason);
                $rootScope.$broadcast("event:auth-loginCancelled", data);
            }
        };
    } ]).config([ "$httpProvider", function($httpProvider) {
        var interceptor = [ "$rootScope", "$q", "httpBuffer", function($rootScope, $q, httpBuffer) {
            function success(response) {
                return response;
            }
            function error(response) {
                if (response.status === 401 && !response.config.ignoreAuthModule) {
                    var deferred = $q.defer();
                    httpBuffer.append(response.config, deferred);
                    $rootScope.$broadcast("event:auth-loginRequired", response);
                    return deferred.promise;
                } else if (response.status == 403) {
                    console.log("User is not authorized for the request");
                    alert("UnAuthorized Action - User does not have Sufficient priviledges to complete the action ");
                } else if (exception.code == 504) {
                    console.log("504 response received, change the state here to show add new records page or something");
                }
                // otherwise, default behaviour
                return $q.reject(response);
            }
            return function(promise) {
                return promise.then(success, error);
            };
        } ];
        $httpProvider.responseInterceptors.push(interceptor);
    } ]);
    /**
* Private module, a utility, required internally by 'http-auth-interceptor'.
*/
    angular.module("http-auth-interceptor-buffer", []).factory("httpBuffer", [ "$injector", function($injector) {
        /** Holds all the requests, so they can be re-requested in future. */
        var buffer = [];
        /** Service initialized later because of circular dependency problem. */
        var $http;
        function retryHttpRequest(config, deferred) {
            function successCallback(response) {
                deferred.resolve(response);
            }
            function errorCallback(response) {
                deferred.reject(response);
            }
            $http = $http || $injector.get("$http");
            $http(config).then(successCallback, errorCallback);
        }
        return {
            /**
* Appends HTTP request configuration object with deferred response attached to buffer.
*/
            append: function(config, deferred) {
                buffer.push({
                    config: config,
                    deferred: deferred
                });
            },
            /**
* Abandon or reject (if reason provided) all the buffered requests.
*/
            rejectAll: function(reason) {
                if (reason) {
                    for (var i in buffer) {
                        buffer[i].deferred.reject(reason);
                    }
                }
                buffer = [];
            },
            /**
* Retries all the buffered requests clears the buffer.
*/
            retryAll: function(updater) {
                //TBD : commented this code as it was not having the token, it has to be changed
                // so that $state has be to used to retry requests
                //for (var i in buffer) {
                //retryHttpRequest(updater(buffer[i].config), buffer[i].deferred);
                //}
                buffer = [];
            }
        };
    } ]);
})();

angular.module("fundoo.services", []).factory("createDialog", [ "$document", "$compile", "$rootScope", "$controller", "$timeout", function($document, $compile, $rootScope, $controller, $timeout) {
    var defaults = {
        id: null,
        template: null,
        templateUrl: null,
        title: "Default Title",
        backdrop: true,
        success: {
            label: "OK",
            fn: null
        },
        cancel: {
            label: "Close",
            fn: null
        },
        controller: null,
        //just like route controller declaration
        backdropClass: "modal-backdrop",
        footerTemplate: null,
        modalClass: "modal",
        css: {}
    };
    var body = $document.find("body");
    return function Dialog(templateUrl, options, passedInLocals) {
        // Handle arguments if optional template isn't provided.
        if (angular.isObject(templateUrl)) {
            passedInLocals = options;
            options = templateUrl;
        } else {
            options.templateUrl = templateUrl;
        }
        options = angular.extend({}, defaults, options);
        //options defined in constructor
        var key;
        var idAttr = options.id ? ' id="' + options.id + '" ' : "";
        var defaultFooter = '<button class="btn" ng-click="$modalCancel()">{{$modalCancelLabel}}</button>' + '<button type="submit" class="btn btn-primary">{{$modalSuccessLabel}}</button>';
        var footerTemplate = '<div class="modal-footer">' + (options.footerTemplate || defaultFooter) + "</div>";
        var modalBody = function() {
            if (options.template) {
                if (angular.isString(options.template)) {
                    // Simple string template
                    return '<div class="modal-body">' + options.template + "</div>";
                } else {
                    // jQuery/JQlite wrapped object
                    return '<div class="modal-body">' + options.template.html() + "</div>";
                }
            } else {
                // Template url
                return '<div class="modal-body" ng-include="\'' + options.templateUrl + "'\"></div>";
            }
        }();
        //We don't have the scope we're gonna use yet, so just get a compile function for modal
        var modalEl = angular.element('<div class="' + options.modalClass + ' fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true"' + idAttr + ">" + '  <div class="modal-dialog">' + '    <div class="modal-content">' + '      <div class="modal-header">' + '        <button type="button" class="close" data-dismiss="modal" aria-hidden="true" ng-click="$modalCancel()">&times;</button>' + '        <h4 class="modal-title">{{$title}}</h4>' + "      </div>" + '      <form ng-submit="submit($modalSuccess)" editable-form>' + modalBody + footerTemplate + "      </form>" + "    </div>" + "  </div>" + "</div>");
        for (key in options.css) {
            modalEl.css(key, options.css[key]);
        }
        var backdropEl = angular.element('<div ng-click="$modalCancel()">');
        backdropEl.addClass(options.backdropClass);
        backdropEl.addClass("fade in");
        var handleEscPressed = function(event) {
            if (event.keyCode === 27) {
                scope.$modalCancel();
            }
        };
        var closeFn = function() {
            body.unbind("keydown", handleEscPressed);
            modalEl.remove();
            if (options.backdrop) {
                backdropEl.remove();
            }
        };
        body.bind("keydown", handleEscPressed);
        var ctrl, locals, scope = options.scope || $rootScope.$new();
        scope.$title = options.title;
        scope.$modalClose = closeFn;
        scope.$modalCancel = function() {
            var callFn = options.cancel.fn || closeFn;
            callFn.call(this);
            scope.$modalClose();
        };
        scope.$modalSuccess = function() {
            var callFn = options.success.fn || closeFn;
            if (arguments) callFn.call(this, arguments[0]); else {
                callFn.call(this);
            }
            scope.$modalClose();
        };
        scope.$modalSuccessLabel = options.success.label;
        scope.$modalCancelLabel = options.cancel.label;
        if (options.controller) {
            locals = angular.extend({
                $scope: scope
            }, passedInLocals);
            ctrl = $controller(options.controller, locals);
            // Yes, ngControllerController is not a typo
            modalEl.contents().data("$ngControllerController", ctrl);
        }
        $compile(modalEl)(scope);
        $compile(backdropEl)(scope);
        body.append(modalEl);
        if (options.backdrop) body.append(backdropEl);
        $timeout(function() {
            modalEl.addClass("in");
        }, 200);
    };
} ]);

(function(define) {
    define([ "jquery" ], function($) {
        return function() {
            var version = "2.0.1";
            var $container;
            var listener;
            var toastId = 0;
            var toastType = {
                error: "error",
                info: "info",
                success: "success",
                warning: "warning"
            };
            var toastr = {
                clear: clear,
                error: error,
                getContainer: getContainer,
                info: info,
                options: {},
                subscribe: subscribe,
                success: success,
                version: version,
                warning: warning
            };
            return toastr;
            //#region Accessible Methods
            function error(message, title, optionsOverride) {
                return notify({
                    type: toastType.error,
                    iconClass: getOptions().iconClasses.error,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function info(message, title, optionsOverride) {
                return notify({
                    type: toastType.info,
                    iconClass: getOptions().iconClasses.info,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function subscribe(callback) {
                listener = callback;
            }
            function success(message, title, optionsOverride) {
                return notify({
                    type: toastType.success,
                    iconClass: getOptions().iconClasses.success,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function warning(message, title, optionsOverride) {
                return notify({
                    type: toastType.warning,
                    iconClass: getOptions().iconClasses.warning,
                    message: message,
                    optionsOverride: optionsOverride,
                    title: title
                });
            }
            function clear($toastElement) {
                var options = getOptions();
                if (!$container) {
                    getContainer(options);
                }
                if ($toastElement && $(":focus", $toastElement).length === 0) {
                    $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function() {
                            removeToast($toastElement);
                        }
                    });
                    return;
                }
                if ($container.children().length) {
                    $container[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function() {
                            $container.remove();
                        }
                    });
                }
            }
            //#endregion
            //#region Internal Methods
            function getDefaults() {
                return {
                    tapToDismiss: true,
                    toastClass: "toast",
                    containerId: "toast-container",
                    debug: false,
                    showMethod: "fadeIn",
                    //fadeIn, slideDown, and show are built into jQuery
                    showDuration: 300,
                    showEasing: "swing",
                    //swing and linear are built into jQuery
                    onShown: undefined,
                    hideMethod: "fadeOut",
                    hideDuration: 1e3,
                    hideEasing: "swing",
                    onHidden: undefined,
                    extendedTimeOut: 1e3,
                    iconClasses: {
                        error: "toast-error",
                        info: "toast-info",
                        success: "toast-success",
                        warning: "toast-warning"
                    },
                    iconClass: "toast-info",
                    positionClass: "toast-top-center",
                    timeOut: 5e3,
                    // Set timeOut and extendedTimeout to 0 to make it sticky
                    titleClass: "toast-title",
                    messageClass: "toast-message",
                    target: "body",
                    closeHtml: "<button>&times;</button>",
                    newestOnTop: true
                };
            }
            function publish(args) {
                if (!listener) {
                    return;
                }
                listener(args);
            }
            function notify(map) {
                var options = getOptions(), iconClass = map.iconClass || options.iconClass;
                if (typeof map.optionsOverride !== "undefined") {
                    options = $.extend(options, map.optionsOverride);
                    iconClass = map.optionsOverride.iconClass || iconClass;
                }
                toastId++;
                $container = getContainer(options);
                var intervalId = null, $toastElement = $("<div/>"), $titleElement = $("<div/>"), $messageElement = $("<div/>"), $closeElement = $(options.closeHtml), response = {
                    toastId: toastId,
                    state: "visible",
                    startTime: new Date(),
                    options: options,
                    map: map
                };
                if (map.iconClass) {
                    $toastElement.addClass(options.toastClass).addClass(iconClass);
                }
                if (map.title) {
                    $titleElement.append(map.title).addClass(options.titleClass);
                    $toastElement.append($titleElement);
                }
                if (map.message) {
                    $messageElement.append(map.message).addClass(options.messageClass);
                    $toastElement.append($messageElement);
                }
                if (options.closeButton) {
                    $closeElement.addClass("toast-close-button");
                    $toastElement.prepend($closeElement);
                }
                $toastElement.hide();
                if (options.newestOnTop) {
                    $container.prepend($toastElement);
                } else {
                    $container.append($toastElement);
                }
                $toastElement[options.showMethod]({
                    duration: options.showDuration,
                    easing: options.showEasing,
                    complete: options.onShown
                });
                if (options.timeOut > 0) {
                    intervalId = setTimeout(hideToast, options.timeOut);
                }
                $toastElement.hover(stickAround, delayedhideToast);
                if (!options.onclick && options.tapToDismiss) {
                    $toastElement.click(hideToast);
                }
                if (options.closeButton && $closeElement) {
                    $closeElement.click(function(event) {
                        event.stopPropagation();
                        hideToast(true);
                    });
                }
                if (options.onclick) {
                    $toastElement.click(function() {
                        options.onclick();
                        hideToast();
                    });
                }
                publish(response);
                if (options.debug && console) {
                    console.log(response);
                }
                return $toastElement;
                function hideToast(override) {
                    if ($(":focus", $toastElement).length && !override) {
                        return;
                    }
                    return $toastElement[options.hideMethod]({
                        duration: options.hideDuration,
                        easing: options.hideEasing,
                        complete: function() {
                            removeToast($toastElement);
                            if (options.onHidden) {
                                options.onHidden();
                            }
                            response.state = "hidden";
                            response.endTime = new Date(), publish(response);
                        }
                    });
                }
                function delayedhideToast() {
                    if (options.timeOut > 0 || options.extendedTimeOut > 0) {
                        intervalId = setTimeout(hideToast, options.extendedTimeOut);
                    }
                }
                function stickAround() {
                    clearTimeout(intervalId);
                    $toastElement.stop(true, true)[options.showMethod]({
                        duration: options.showDuration,
                        easing: options.showEasing
                    });
                }
            }
            function getContainer(options) {
                if (!options) {
                    options = getOptions();
                }
                $container = $("#" + options.containerId);
                if ($container.length) {
                    return $container;
                }
                $container = $("<div/>").attr("id", options.containerId).addClass(options.positionClass);
                $container.appendTo($(options.target));
                return $container;
            }
            function getOptions() {
                return $.extend({}, getDefaults(), toastr.options);
            }
            function removeToast($toastElement) {
                if (!$container) {
                    $container = getContainer();
                }
                if ($toastElement.is(":visible")) {
                    return;
                }
                $toastElement.remove();
                $toastElement = null;
                if ($container.children().length === 0) {
                    $container.remove();
                }
            }
        }();
    });
})(typeof define === "function" && define.amd ? define : function(deps, factory) {
    if (typeof module !== "undefined" && module.exports) {
        //Node
        module.exports = factory(require(deps[0]));
    } else {
        window["toastr"] = factory(window["jQuery"]);
    }
});

angular.module("ui.bootstrap.position", []).factory("$position", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        if (el.currentStyle) {
            //IE
            return el.currentStyle[cssprop];
        } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop];
        }
        // finally try and get inline style
        return el.style[cssprop];
    }
    /**
       * Checks if a given element is statically positioned
       * @param element - raw DOM element
       */
    function isStaticPositioned(element) {
        return (getStyle(element, "position") || "static") === "static";
    }
    /**
       * returns the closest, non-statically positioned parentOffset of a given element
       * @param element
       */
    var parentOffsetEl = function(element) {
        var docDomEl = $document[0];
        var offsetParent = element.offsetParent || docDomEl;
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docDomEl;
    };
    return {
        /**
           * Provides read-only equivalent of jQuery's position function:
           * http://api.jquery.com/position/
           */
        position: function(element) {
            var elBCR = this.offset(element);
            var offsetParentBCR = {
                top: 0,
                left: 0
            };
            var offsetParentEl = parentOffsetEl(element[0]);
            if (offsetParentEl != $document[0]) {
                offsetParentBCR = this.offset(angular.element(offsetParentEl));
                offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
                offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        /**
           * Provides read-only equivalent of jQuery's offset function:
           * http://api.jquery.com/offset/
           */
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
            };
        }
    };
} ]);

angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function() {
    return function(scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe);
        scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
            element.html(value || "");
        });
    };
});

angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).factory("typeaheadParser", [ "$parse", function($parse) {
    //                      00000111000000000000022200000000000000003333333333333330000000000044000
    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
            if (!match) {
                throw new Error("Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" + " but got '" + input + "'.");
            }
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ];
    return {
        require: "ngModel",
        link: function(originalScope, element, attrs, modelCtrl) {
            //SUPPORTED ATTRIBUTES (OPTIONS)
            //minimal no of characters that needs to be entered before typeahead kicks-in
            var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;
            //minimal wait time after last character typed before typehead kicks-in
            var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
            //should it restrict model values to the ones selected from the popup only?
            var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
            //binding to a variable that indicates if matches are being retrieved asynchronously
            var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
            //a callback executed when a match is selected
            var onSelectCallback = $parse(attrs.typeaheadOnSelect);
            var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
            //INTERNAL VARIABLES
            //model setter executed upon match selection
            var $setModelValue = $parse(attrs.ngModel).assign;
            //expressions used by typeahead
            var parserResult = typeaheadParser.parse(attrs.typeahead);
            var hasFocus;
            //pop-up element used to display matches
            var popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            });
            //custom item template
            if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
                popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
            }
            //create a child scope for the typeahead directive so we are not polluting original scope
            //with typeahead-specific data (matches, query etc.)
            var scope = originalScope.$new();
            originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            var resetMatches = function() {
                scope.matches = [];
                scope.activeIdx = -1;
            };
            var getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, true);
                $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    //it might happen that several async queries were in progress if a user were typing fast
                    //but we are interested only in responses that correspond to the current view value
                    if (inputValue === modelCtrl.$viewValue && hasFocus) {
                        if (matches.length > 0) {
                            scope.activeIdx = 0;
                            scope.matches.length = 0;
                            //transform labels
                            for (var i = 0; i < matches.length; i++) {
                                locals[parserResult.itemName] = matches[i];
                                scope.matches.push({
                                    label: parserResult.viewMapper(scope, locals),
                                    model: matches[i]
                                });
                            }
                            scope.query = inputValue;
                            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                            //due to other elements being rendered
                            scope.position = $position.position(element);
                            scope.position.top = scope.position.top + element.prop("offsetHeight");
                        } else {
                            resetMatches();
                        }
                        isLoadingSetter(originalScope, false);
                    }
                }, function() {
                    resetMatches();
                    isLoadingSetter(originalScope, false);
                });
            };
            resetMatches();
            //we need to propagate user's query so we can higlight matches
            scope.query = undefined;
            //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
            var timeoutPromise;
            //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
            //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
            modelCtrl.$parsers.unshift(function(inputValue) {
                hasFocus = true;
                if (inputValue && inputValue.length >= minSearch) {
                    if (waitTime > 0) {
                        if (timeoutPromise) {
                            $timeout.cancel(timeoutPromise);
                        }
                        timeoutPromise = $timeout(function() {
                            getMatchesAsync(inputValue);
                        }, waitTime);
                    } else {
                        getMatchesAsync(inputValue);
                    }
                } else {
                    isLoadingSetter(originalScope, false);
                    resetMatches();
                }
                if (isEditable) {
                    return inputValue;
                } else {
                    if (!inputValue) {
                        // Reset in case user had typed something previously.
                        modelCtrl.$setValidity("editable", true);
                        return inputValue;
                    } else {
                        modelCtrl.$setValidity("editable", false);
                        return undefined;
                    }
                }
            });
            modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue;
                var locals = {};
                if (inputFormatter) {
                    locals["$model"] = modelValue;
                    return inputFormatter(originalScope, locals);
                } else {
                    //it might happen that we don't have enough info to properly render input value
                    //we need to check for this situation and simply return model value if we can't apply custom formatting
                    locals[parserResult.itemName] = modelValue;
                    candidateViewValue = parserResult.viewMapper(originalScope, locals);
                    locals[parserResult.itemName] = undefined;
                    emptyViewValue = parserResult.viewMapper(originalScope, locals);
                    return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
                }
            });
            scope.select = function(activeIdx) {
                //called from within the $digest() cycle
                var locals = {};
                var model, item;
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
                model = parserResult.modelMapper(originalScope, locals);
                $setModelValue(originalScope, model);
                modelCtrl.$setValidity("editable", true);
                onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                });
                resetMatches();
                //return focus to the input element if a mach was selected via a mouse click event
                element[0].focus();
            };
            //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
            element.bind("keydown", function(evt) {
                //typeahead is open and an "interesting" key was pressed
                if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                    if (evt.which === 13) {
                        evt.preventDefault();
                    }
                    return;
                }
                evt.preventDefault();
                if (evt.which === 40) {
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                    scope.$digest();
                } else if (evt.which === 38) {
                    scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
                    scope.$digest();
                } else if (evt.which === 13 || evt.which === 9) {
                    scope.$apply(function() {
                        scope.select(scope.activeIdx);
                    });
                } else if (evt.which === 27) {
                    evt.stopPropagation();
                    resetMatches();
                    scope.$digest();
                }
            });
            element.bind("blur", function(evt) {
                hasFocus = false;
            });
            // Keep reference to click handler to unbind it.
            var dismissClickHandler = function(evt) {
                if (element[0] !== evt.target) {
                    resetMatches();
                    scope.$digest();
                }
            };
            $document.bind("click", dismissClickHandler);
            originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler);
            });
            element.after($compile(popUpEl)(scope));
        }
    };
} ]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "=",
            select: "&"
        },
        replace: true,
        templateUrl: "/shared/typeahead-popup.html",
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl;
            scope.isOpen = function() {
                return scope.matches.length > 0;
            };
            scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            };
            scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            };
            scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
            scope.createNewOrg = function(name) {
                alert(name + "3");
            };
        }
    };
}).directive("typeaheadMatch", [ "$http", "$templateCache", "$compile", "$parse", function($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "/shared/typeahead-match.html";
            $http.get(tplUrl, {
                cache: $templateCache
            }).success(function(tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope));
            });
        }
    };
} ]).filter("typeaheadHighlight", function() {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    return function(matchItem, query) {
        return query ? matchItem.replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem;
    };
});

/*!
angular-xeditable - 0.1.7
Edit-in-place for angular.js
Build date: 2013-10-26 
*/
/*
angular-xeditable module
*/
angular.module("xeditable", []).value("editableOptions", {
    theme: "default",
    //bs2, bs3,
    buttons: "right",
    blur: "cancel"
});

/*
Angular-ui bootstrap datepicker
http://angular-ui.github.io/bootstrap/#/datepicker
*/
angular.module("xeditable").directive("editableBsdate", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableBsdate",
        inputTpl: '<input type="text">'
    });
} ]);

/*
Angular-ui bootstrap editable timepicker
http://angular-ui.github.io/bootstrap/#/timepicker
*/
angular.module("xeditable").directive("editableBstime", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableBstime",
        inputTpl: "<timepicker></timepicker>",
        render: function() {
            this.parent.render.call(this);
            // timepicker can't update model when ng-model set directly to it
            // see: https://github.com/angular-ui/bootstrap/issues/1141
            // so we wrap it into DIV
            var div = angular.element('<div class="well well-small" style="display:inline-block;"></div>');
            // move ng-model to wrapping div
            div.attr("ng-model", this.inputEl.attr("ng-model"));
            this.inputEl.removeAttr("ng-model");
            // move ng-change to wrapping div
            if (this.attrs.eNgChange) {
                div.attr("ng-change", this.inputEl.attr("ng-change"));
                this.inputEl.removeAttr("ng-change");
            }
            // wrap
            this.inputEl.wrap(div);
        }
    });
} ]);

//checkbox
angular.module("xeditable").directive("editableCheckbox", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableCheckbox",
        inputTpl: '<input type="checkbox">',
        render: function() {
            this.parent.render.call(this);
            if (this.attrs.eTitle) {
                this.inputEl.wrap("<label></label>");
                this.inputEl.after(angular.element("<span></span>").text(" " + this.attrs.eTitle));
            }
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                setTimeout(function() {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }, 500);
            });
        }
    });
} ]);

/*
Input types: text|email|tel|number|url|search|color|date|datetime|time|month|week
*/
(function() {
    var types = "text|email|tel|number|url|search|color|date|datetime|time|month|week".split("|");
    //todo: datalist
    // generate directives
    angular.forEach(types, function(type) {
        var directiveName = "editable" + type.charAt(0).toUpperCase() + type.slice(1);
        angular.module("xeditable").directive(directiveName, [ "editableDirectiveFactory", function(editableDirectiveFactory) {
            return editableDirectiveFactory({
                directiveName: directiveName,
                inputTpl: '<input type="' + type + '">'
            });
        } ]);
    });
    //`range` is bit specific
    angular.module("xeditable").directive("editableRange", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
        return editableDirectiveFactory({
            directiveName: "editableRange",
            inputTpl: '<input type="range" id="range" name="range">',
            render: function() {
                this.parent.render.call(this);
                this.inputEl.after("<output>{{$data}}</output>");
            }
        });
    } ]);
})();

//select
angular.module("xeditable").directive("editableSelect", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableSelect",
        inputTpl: "<select></select>",
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("change", function() {
                self.scope.$apply(function() {
                    self.scope.$form.$submit();
                });
            });
        }
    });
} ]);

//textarea
angular.module("xeditable").directive("editableTextarea", [ "editableDirectiveFactory", function(editableDirectiveFactory) {
    return editableDirectiveFactory({
        directiveName: "editableTextarea",
        inputTpl: "<textarea></textarea>",
        addListeners: function() {
            var self = this;
            self.parent.addListeners.call(self);
            // submit textarea by ctrl+enter even with buttons
            if (self.single && self.buttons !== "no") {
                self.autosubmit();
            }
        },
        autosubmit: function() {
            var self = this;
            self.inputEl.bind("keydown", function(e) {
                if ((e.ctrlKey || e.metaKey) && e.keyCode === 13) {
                    self.scope.$apply(function() {
                        self.scope.$form.$submit();
                    });
                }
            });
        }
    });
} ]);

/**
 * EditableController class. 
 * Attached to element with `editable-xxx` directive.
 *
 * @namespace editable-element
 */
/*
TODO: this file should be refactored to work more clear without closures!
*/
angular.module("xeditable").factory("editableController", [ "$q", "$document", "editableUtils", "$rootScope", function($q, $document, utils, $rootScope) {
    // array of opened editable controls
    var shown = [];
    // bind click to body: cancel|submit editables
    $document.bind("click", function(e) {
        // ignore right/middle button click
        if (e.which !== 1) {
            return;
        }
        var toCancel = [];
        var toSubmit = [];
        for (var i = 0; i < shown.length; i++) {
            // exclude self
            if (shown[i].clicked) {
                shown[i].clicked = false;
                continue;
            }
            if (shown[i].blur === "cancel") {
                toCancel.push(shown[i]);
            }
            if (shown[i].blur === "submit") {
                toSubmit.push(shown[i]);
            }
        }
        if (toCancel.length || toSubmit.length) {
            $rootScope.$apply(function() {
                angular.forEach(toCancel, function(v) {
                    v.scope.$form.$hide();
                });
                angular.forEach(toSubmit, function(v) {
                    v.scope.$form.$submit();
                });
            });
        }
    });
    //EditableController function
    EditableController.$inject = [ "$scope", "$attrs", "$element", "$parse", "editableThemes", "editableOptions", "$rootScope", "$compile", "$q" ];
    function EditableController($scope, $attrs, $element, $parse, editableThemes, editableOptions, $rootScope, $compile, $q) {
        var valueGetter;
        //if control is disabled - it does not participate in waiting process
        var inWaiting;
        var self = this;
        self.scope = $scope;
        self.elem = $element;
        self.attrs = $attrs;
        self.inputEl = null;
        self.editorEl = null;
        self.single = true;
        self.error = "";
        self.theme = editableThemes[editableOptions.theme] || editableThemes["default"];
        self.parent = {};
        self.clicked = false;
        //used to check in document click handler if control was clicked or not
        //to be overwritten by directive
        self.inputTpl = "";
        self.directiveName = "";
        //runtime (defaults)
        self.single = null;
        /**
           * Attributes defined with `e-*` prefix automatically transfered from original element to
           * control.  
           * For example, if you set `<span editable-text="user.name" e-style="width: 100px"`>
           * then input will appear as `<input style="width: 100px">`.  
           * See [demo](#text-customize).
           * 
           * @var {any|attribute} e-*
           * @memberOf editable-element
           */
        /**
           * Whether to show ok/cancel buttons. Values: `right|no`.
           * If set to `no` control automatically submitted when value changed.  
           * If control is part of form buttons will never be shown. 
           * 
           * @var {string|attribute} buttons
           * @memberOf editable-element
           */
        self.buttons = "right";
        /**
           * Action when control losses focus. Values: `cancel|submit|ignore`.
           * If control is part of form `blur` automatically set to `ignore`.  
           * 
           * @var {string|attribute} blur
           * @memberOf editable-element
           */
        self.blur = "ignore";
        // can be 'cancel|submit|ignore'
        //init
        self.init = function(single) {
            self.single = single;
            self.name = $attrs.eName || $attrs[self.directiveName];
            /*
              if(!$attrs[directiveName] && !$attrs.eNgModel && ($attrs.eValue === undefined)) {
                throw 'You should provide value for `'+directiveName+'` or `e-value` in editable element!';
              }
              */
            if ($attrs[self.directiveName]) {
                valueGetter = $parse($attrs[self.directiveName]);
            } else {
                throw "You should provide value for `" + self.directiveName + "` in editable element!";
            }
            // settings for single and non-single
            if (!self.single) {
                // hide buttons for non-single
                self.buttons = "no";
                self.blur = "ignore";
            } else {
                self.buttons = self.attrs.buttons || editableOptions.buttons;
                self.blur = self.attrs.blur || (self.buttons === "no" ? "cancel" : editableOptions.blur);
            }
            //moved to show()
            //self.render();
            //if name defined --> watch changes and update $data in form
            if ($attrs.eName) {
                self.scope.$watch("$data", function(newVal) {
                    self.scope.$form.$data[$attrs.eName] = newVal;
                });
            }
            /**
               * Called when control is shown.  
               * See [demo](#select-remote).
               * 
               * @var {method|attribute} onshow
               * @memberOf editable-element
               */
            if ($attrs.onshow) {
                self.onshow = function() {
                    return self.catchError($parse($attrs.onshow)($scope));
                };
            }
            /**
               * Called when control is hidden after both save or cancel.  
               * 
               * @var {method|attribute} onhide
               * @memberOf editable-element
               */
            if ($attrs.onhide) {
                self.onhide = function() {
                    return $parse($attrs.onhide)($scope);
                };
            }
            /**
               * Called when control is cancelled.  
               * 
               * @var {method|attribute} oncancel
               * @memberOf editable-element
               */
            if ($attrs.oncancel) {
                self.oncancel = function() {
                    return $parse($attrs.oncancel)($scope);
                };
            }
            /**
               * Called during submit before value is saved to model.  
               * See [demo](#onbeforesave).
               * 
               * @var {method|attribute} onbeforesave
               * @memberOf editable-element
               */
            if ($attrs.onbeforesave) {
                self.onbeforesave = function() {
                    return self.catchError($parse($attrs.onbeforesave)($scope));
                };
            }
            /**
               * Called during submit after value is saved to model.  
               * See [demo](#onaftersave).
               * 
               * @var {method|attribute} onaftersave
               * @memberOf editable-element
               */
            if ($attrs.onaftersave) {
                self.onaftersave = function() {
                    return self.catchError($parse($attrs.onaftersave)($scope));
                };
            }
            // watch change of model to update editable element
            // now only add/remove `editable-empty` class.
            // Initially this method called with newVal = undefined, oldVal = undefined
            // so no need initially call handleEmpty() explicitly
            $scope.$parent.$watch($attrs[self.directiveName], function(newVal, oldVal) {
                self.handleEmpty();
            });
        };
        self.render = function() {
            var theme = self.theme;
            //build input
            self.inputEl = angular.element(self.inputTpl);
            //build controls
            self.controlsEl = angular.element(theme.controlsTpl);
            self.controlsEl.append(self.inputEl);
            //build buttons
            if (self.buttons !== "no") {
                self.buttonsEl = angular.element(theme.buttonsTpl);
                self.submitEl = angular.element(theme.submitTpl);
                self.cancelEl = angular.element(theme.cancelTpl);
                self.buttonsEl.append(self.submitEl).append(self.cancelEl);
                self.controlsEl.append(self.buttonsEl);
                self.inputEl.addClass("editable-has-buttons");
            }
            //build error
            self.errorEl = angular.element(theme.errorTpl);
            self.controlsEl.append(self.errorEl);
            //build editor
            self.editorEl = angular.element(self.single ? theme.formTpl : theme.noformTpl);
            self.editorEl.append(self.controlsEl);
            // transfer `e-*|data-e-*|x-e-*` attributes
            for (var k in $attrs.$attr) {
                if (k.length <= 1) {
                    continue;
                }
                var transferAttr = false;
                var nextLetter = k.substring(1, 2);
                // if starts with `e` + uppercase letter
                if (k.substring(0, 1) === "e" && nextLetter === nextLetter.toUpperCase()) {
                    transferAttr = k.substring(1);
                } else {
                    continue;
                }
                // exclude `form` and `ng-submit`, 
                if (transferAttr === "Form" || transferAttr === "NgSubmit") {
                    continue;
                }
                // convert back to lowercase style
                transferAttr = transferAttr.substring(0, 1).toLowerCase() + utils.camelToDash(transferAttr.substring(1));
                // workaround for attributes without value (e.g. `multiple = "multiple"`)
                var attrValue = $attrs[k] === "" ? transferAttr : $attrs[k];
                // set attributes to input
                self.inputEl.attr(transferAttr, attrValue);
            }
            self.inputEl.addClass("editable-input");
            self.inputEl.attr("ng-model", "$data");
            // add directiveName class to editor, e.g. `editable-text`
            self.editorEl.addClass(utils.camelToDash(self.directiveName));
            if (self.single) {
                self.editorEl.attr("editable-form", "$form");
            }
            //apply `postrender` method of theme
            if (angular.isFunction(theme.postrender)) {
                theme.postrender.call(self);
            }
        };
        //show
        self.show = function() {
            // set value. copy not needed.
            // self.scope.$data = angular.copy(valueGetter($scope.$parent));
            self.scope.$data = valueGetter($scope.$parent);
            /*
              Originally render() was inside init() method, but some directives polluting editorEl,
              so it is broken on second openning.
              Cloning is not a solution as jqLite can not clone with event handler's.
              */
            self.render();
            // insert into DOM
            $element.after(self.editorEl);
            // compile (needed to attach ng-* events from markup)
            $compile(self.editorEl)($scope);
            // attach listeners (`escape`, autosubmit, etc)
            self.addListeners();
            // hide element
            $element.addClass("editable-hide");
            // add to internal list
            // setTimeout needed to prevent closing right after opening (e.g. when trigger by button)
            setTimeout(function() {
                if (utils.indexOf(shown, self) === -1) {
                    shown.push(self);
                }
            }, 0);
            // onshow
            return self.onshow();
        };
        //hide
        self.hide = function() {
            //console.log('editable hide', self.name);
            self.editorEl.remove();
            $element.removeClass("editable-hide");
            // remove from internal list
            utils.arrayRemove(shown, self);
            // onhide
            return self.onhide();
        };
        // cancel
        self.cancel = function() {
            // oncancel
            self.oncancel();
        };
        /*
          Called after show to attach listeners
          */
        self.addListeners = function() {
            // bind keyup for `escape`
            self.inputEl.bind("keyup", function(e) {
                if (!self.single) {
                    return;
                }
                switch (e.keyCode) {
                  // hide on `escape` press
                    case 27:
                    self.scope.$form.$cancel();
                    break;
                }
            });
            // autosubmit when `no buttons`
            if (self.single && self.buttons === "no") {
                self.autosubmit();
            }
            // click - mark element as clicked to exclude in document click handler
            self.editorEl.bind("click", function(e) {
                // ignore right/middle button click
                if (e.which !== 1) {
                    return;
                }
                self.clicked = true;
            });
        };
        // setWaiting
        self.setWaiting = function(value) {
            if (value) {
                //participate in waiting only if not disabled
                inWaiting = !self.inputEl.attr("disabled") && !self.inputEl.attr("ng-disabled") && !self.inputEl.attr("ng-enabled");
                if (inWaiting) {
                    self.inputEl.attr("disabled", "disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").attr("disabled", "disabled");
                    }
                }
            } else {
                if (inWaiting) {
                    self.inputEl.removeAttr("disabled");
                    if (self.buttonsEl) {
                        self.buttonsEl.find("button").removeAttr("disabled");
                    }
                }
            }
        };
        self.activate = function() {
            setTimeout(function() {
                self.inputEl[0].focus();
            }, 0);
        };
        self.setError = function(msg) {
            if (!angular.isObject(msg)) {
                $scope.$error = msg;
                self.error = msg;
            }
        };
        /*
          Checks that result is string or promise returned string and shows it as error message
          Applied to onshow, onbeforesave, onaftersave
          */
        self.catchError = function(result, noPromise) {
            if (angular.isObject(result) && noPromise !== true) {
                $q.when(result).then(//success and fail handlers are equal
                angular.bind(this, function(r) {
                    this.catchError(r, true);
                }), angular.bind(this, function(r) {
                    this.catchError(r, true);
                }));
            } else if (noPromise && angular.isObject(result) && result.status && result.status !== 200 && result.data && angular.isString(result.data)) {
                this.setError(result.data);
                //set result to string: to let form know that there was error
                result = result.data;
            } else if (angular.isString(result)) {
                this.setError(result);
            }
            return result;
        };
        self.save = function() {
            valueGetter.assign($scope.$parent, angular.copy(self.scope.$data));
        };
        /*
          attach/detach `editable-empty` class to element
          */
        self.handleEmpty = function() {
            var val = valueGetter($scope.$parent);
            var isEmpty = val === null || val === undefined || val === "" || angular.isArray(val) && val.length === 0;
            $element.toggleClass("editable-empty", isEmpty);
        };
        /*
          Called when `buttons = "no"` to submit automatically
          */
        self.autosubmit = angular.noop;
        self.onshow = angular.noop;
        self.onhide = angular.noop;
        self.oncancel = angular.noop;
        self.onbeforesave = angular.noop;
        self.onaftersave = angular.noop;
    }
    return EditableController;
} ]);

/*
editableFactory:
- attaches editableController to element
- used to generate editable directives

Depends on: editableController, editableFormFactory
*/
angular.module("xeditable").factory("editableDirectiveFactory", [ "$parse", "$compile", "editableThemes", "$rootScope", "$document", "editableController", "editableFormController", function($parse, $compile, editableThemes, $rootScope, $document, editableController, editableFormController) {
    //directive object
    return function(overwrites) {
        return {
            restrict: "A",
            scope: true,
            require: [ overwrites.directiveName, "?^form" ],
            controller: editableController,
            link: function(scope, elem, attrs, ctrl) {
                //editable controller
                var eCtrl = ctrl[0];
                //form controller
                var eFormCtrl;
                var hasForm = false;
                //if not inside form, but we have `e-form`:
                //check if form exists somewhere in scope. If exists - bind, otherwise create.
                if (ctrl[1]) {
                    eFormCtrl = ctrl[1];
                    hasForm = true;
                } else if (attrs.eForm) {
                    var getter = $parse(attrs.eForm)(scope);
                    if (getter) {
                        //getter defined, form above
                        eFormCtrl = getter;
                        hasForm = true;
                    } else {
                        //form below or not exist: check document.forms
                        for (var i = 0; i < $document[0].forms.length; i++) {
                            if ($document[0].forms[i].name === attrs.eForm) {
                                //form is below and not processed yet
                                eFormCtrl = null;
                                hasForm = true;
                                break;
                            }
                        }
                    }
                }
                /*
                if(hasForm && !attrs.eName) {
                  throw 'You should provide `e-name` for editable element inside form!';
                }
                */
                //check for `editable-form` attr in form
                /*
                if(eFormCtrl && ) {
                  throw 'You should provide `e-name` for editable element inside form!';
                }
                */
                //store original props to `parent` before merge
                angular.forEach(overwrites, function(v, k) {
                    if (eCtrl[k] !== undefined) {
                        eCtrl.parent[k] = eCtrl[k];
                    }
                });
                //merge overwrites to base editable controller
                angular.extend(eCtrl, overwrites);
                //init editable ctrl
                eCtrl.init(!hasForm);
                //publich editable controller as `$editable` to be referenced in html
                scope.$editable = eCtrl;
                // add `editable` class to element
                elem.addClass("editable");
                // hasForm
                if (hasForm) {
                    if (eFormCtrl) {
                        scope.$form = eFormCtrl;
                        if (!scope.$form.$addEditable) {
                            throw "Form with editable elements should have `editable-form` attribute.";
                        }
                        scope.$form.$addEditable(eCtrl);
                    } else {
                        // future form (below): add editable controller to buffer and add to form later
                        $rootScope.$$editableBuffer = $rootScope.$$editableBuffer || {};
                        $rootScope.$$editableBuffer[attrs.eForm] = $rootScope.$$editableBuffer[attrs.eForm] || [];
                        $rootScope.$$editableBuffer[attrs.eForm].push(eCtrl);
                        scope.$form = null;
                    }
                } else {
                    //create editableform controller
                    scope.$form = editableFormController();
                    //add self to editable controller
                    scope.$form.$addEditable(eCtrl);
                    //elem.after(self.editorEl);
                    //console.log('w:', scope.$$watchers.length);
                    //$compile(eCtrl.editorEl)(scope);
                    //scope.$form.$addEditable(eCtrl);
                    //console.log('w:', scope.$$watchers.length);
                    //eCtrl.editorEl.remove();
                    //if `e-form` provided, publish local $form in scope
                    if (attrs.eForm) {
                        scope.$parent[attrs.eForm] = scope.$form;
                    }
                    //bind click - if no external form defined
                    if (!attrs.eForm) {
                        elem.addClass("editable-click");
                        elem.bind("click", function(e) {
                            e.preventDefault();
                            e.editable = eCtrl;
                            scope.$apply(function() {
                                scope.$form.$show();
                            });
                        });
                    }
                }
            }
        };
    };
} ]);

/*
Returns editableForm controller
*/
angular.module("xeditable").factory("editableFormController", [ "$parse", "editablePromiseCollection", function($parse, editablePromiseCollection) {
    var base = {
        $addEditable: function(editable) {
            //console.log('add editable', editable.elem, editable.elem.bind);
            this.$editables.push(editable);
            //'on' is not supported in angular 1.0.8
            editable.elem.bind("$destroy", angular.bind(this, this.$removeEditable, editable));
            //bind editable's local $form to self (if not bound yet, below form) 
            if (!editable.scope.$form) {
                editable.scope.$form = this;
            }
            //if form already shown - call show() of new editable
            if (this.$visible) {
                editable.catchError(editable.show());
            }
        },
        $removeEditable: function(editable) {
            //arrayRemove
            for (var i = 0; i < this.$editables.length; i++) {
                if (this.$editables[i] === editable) {
                    this.$editables.splice(i, 1);
                    return;
                }
            }
        },
        /**
           * Shows form with editable controls.
           * 
           * @method $show()
           * @memberOf editable-form
           */
        $show: function() {
            if (this.$visible) {
                return;
            }
            this.$visible = true;
            var pc = editablePromiseCollection();
            //own show
            pc.when(this.$onshow());
            //clear errors
            this.$setError(null, "");
            //children show
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.show());
            });
            //wait promises and activate
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, this.$activate),
                onFalse: angular.bind(this, this.$activate),
                onString: angular.bind(this, this.$activate)
            });
        },
        /**
           * Sets focus on form field specified by `name`.
           * 
           * @method $activate(name)
           * @param {string} name name of field
           * @memberOf editable-form
           */
        $activate: function(name) {
            var i;
            if (this.$editables.length) {
                //activate by name
                if (angular.isString(name)) {
                    for (i = 0; i < this.$editables.length; i++) {
                        if (this.$editables[i].name === name) {
                            this.$editables[i].activate();
                            return;
                        }
                    }
                }
                //try activate error field
                for (i = 0; i < this.$editables.length; i++) {
                    if (this.$editables[i].error) {
                        this.$editables[i].activate();
                        return;
                    }
                }
                //by default activate first field
                this.$editables[0].activate();
            }
        },
        /**
           * Hides form with editable controls without saving.
           * 
           * @method $hide()
           * @memberOf editable-form
           */
        $hide: function() {
            if (!this.$visible) {
                return;
            }
            this.$visible = false;
            // self hide
            this.$onhide();
            // children's hide
            angular.forEach(this.$editables, function(editable) {
                editable.hide();
            });
        },
        /**
           * Triggers `oncancel` event and calls `$hide()`.
           * 
           * @method $cancel()
           * @memberOf editable-form
           */
        $cancel: function() {
            if (!this.$visible) {
                return;
            }
            // self cancel
            this.$oncancel();
            // children's cancel      
            angular.forEach(this.$editables, function(editable) {
                editable.cancel();
            });
            // self hide
            this.$hide();
        },
        $setWaiting: function(value) {
            this.$waiting = !!value;
            // we can't just set $waiting variable and use it via ng-disabled in children
            // because in editable-row form is not accessible
            angular.forEach(this.$editables, function(editable) {
                editable.setWaiting(!!value);
            });
        },
        /**
           * Shows error message for particular field.
           * 
           * @method $setError(name, msg)
           * @param {string} name name of field
           * @param {string} msg error message
           * @memberOf editable-form
           */
        $setError: function(name, msg) {
            angular.forEach(this.$editables, function(editable) {
                if (!name || editable.name === name) {
                    editable.setError(msg);
                }
            });
        },
        $submit: function() {
            if (this.$waiting) {
                return;
            }
            //clear errors
            this.$setError(null, "");
            //children onbeforesave
            var pc = editablePromiseCollection();
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onbeforesave());
            });
            /*
              onbeforesave result:
              - true/undefined: save data and close form
              - false: close form without saving
              - string: keep form open and show error
              */
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, checkSelf, true),
                onFalse: angular.bind(this, checkSelf, false),
                onString: angular.bind(this, this.$activate)
            });
            //save
            function checkSelf(childrenTrue) {
                var pc = editablePromiseCollection();
                pc.when(this.$onbeforesave());
                pc.then({
                    onWait: angular.bind(this, this.$setWaiting),
                    onTrue: childrenTrue ? angular.bind(this, this.$save) : angular.bind(this, this.$hide),
                    onFalse: angular.bind(this, this.$hide),
                    onString: angular.bind(this, this.$activate)
                });
            }
        },
        $save: function() {
            // write model for each editable
            angular.forEach(this.$editables, function(editable) {
                editable.save();
            });
            //call onaftersave of self and children
            var pc = editablePromiseCollection();
            pc.when(this.$onaftersave());
            angular.forEach(this.$editables, function(editable) {
                pc.when(editable.onaftersave());
            });
            /*
              onaftersave result:
              - true/undefined/false: just close form
              - string: keep form open and show error
              */
            pc.then({
                onWait: angular.bind(this, this.$setWaiting),
                onTrue: angular.bind(this, this.$hide),
                onFalse: angular.bind(this, this.$hide),
                onString: angular.bind(this, this.$activate)
            });
        },
        $onshow: angular.noop,
        $oncancel: angular.noop,
        $onhide: angular.noop,
        $onbeforesave: angular.noop,
        $onaftersave: angular.noop
    };
    return function() {
        return angular.extend({
            $editables: [],
            /**
               * Form visibility flag.
               * 
               * @var {bool} $visible
               * @memberOf editable-form
               */
            $visible: false,
            /**
               * Form waiting flag. It becomes `true` when form is loading or saving data.
               * 
               * @var {bool} $waiting
               * @memberOf editable-form
               */
            $waiting: false,
            $data: {}
        }, base);
    };
} ]);

/**
 * EditableForm directive. Should be defined in <form> containing editable controls.  
 * It add some usefull methods to form variable exposed to scope by `name="myform"` attribute.
 *
 * @namespace editable-form
 */
angular.module("xeditable").directive("editableForm", [ "$rootScope", "$parse", "editableFormController", function($rootScope, $parse, editableFormController) {
    return {
        restrict: "A",
        require: [ "form" ],
        //require: ['form', 'editableForm'],
        //controller: EditableFormController,
        compile: function() {
            return {
                pre: function(scope, elem, attrs, ctrl) {
                    var form = ctrl[0];
                    var eForm;
                    /*
                      Maybe it's better attach editable controller to form's controller not in pre()
                      but in controller itself. 
                      This allows to use ng-init already in <form> tag, otherwise we can't (in FF).
                      */
                    //if `editableForm` has value - publish smartly under this value
                    //this is required only for single editor form that is created and removed
                    if (attrs.editableForm) {
                        if (scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                            eForm = scope[attrs.editableForm];
                            angular.extend(form, eForm);
                        } else {
                            eForm = editableFormController();
                            scope[attrs.editableForm] = eForm;
                            angular.extend(eForm, form);
                        }
                    } else {
                        //just merge to form and publish if form has name
                        eForm = editableFormController();
                        angular.extend(form, eForm);
                    }
                    //read editables from buffer (that appeared before FORM tag)
                    var buf = $rootScope.$$editableBuffer;
                    var name = form.$name;
                    if (name && buf && buf[name]) {
                        angular.forEach(buf[name], function(editable) {
                            eForm.$addEditable(editable);
                        });
                        delete buf[name];
                    }
                },
                post: function(scope, elem, attrs, ctrl) {
                    var eForm;
                    if (attrs.editableForm && scope[attrs.editableForm] && scope[attrs.editableForm].$show) {
                        eForm = scope[attrs.editableForm];
                    } else {
                        eForm = ctrl[0];
                    }
                    /**
                       * Called when form is shown.
                       * 
                       * @var {method|attribute} onshow 
                       * @memberOf editable-form
                       */
                    if (attrs.onshow) {
                        eForm.$onshow = angular.bind(eForm, $parse(attrs.onshow), scope);
                    }
                    /**
                       * Called when form hides after both save or cancel.
                       * 
                       * @var {method|attribute} onhide 
                       * @memberOf editable-form
                       */
                    if (attrs.onhide) {
                        eForm.$onhide = angular.bind(eForm, $parse(attrs.onhide), scope);
                    }
                    /**
                       * Called when form is cancelled.
                       * 
                       * @var {method|attribute} oncancel
                       * @memberOf editable-form
                       */
                    if (attrs.oncancel) {
                        eForm.$oncancel = angular.bind(eForm, $parse(attrs.oncancel), scope);
                    }
                    /**
                       * Whether form initially rendered in shown state.
                       *
                       * @var {bool|attribute} shown
                       * @memberOf editable-form
                       */
                    if (attrs.shown && $parse(attrs.shown)(scope)) {
                        eForm.$show();
                    }
                    // onbeforesave, onaftersave
                    if (!attrs.ngSubmit && !attrs.submit) {
                        /**
                           * Called after all children `onbeforesave` callbacks but before saving form values
                           * to model.  
                           * If at least one children callback returns `non-string` - it will not not be called.  
                           * See [editable-form demo](#editable-form) for details.
                           * 
                           * @var {method|attribute} onbeforesave
                           * @memberOf editable-form
                           * 
                           */
                        if (attrs.onbeforesave) {
                            eForm.$onbeforesave = function() {
                                return $parse(attrs.onbeforesave)(scope, {
                                    $data: eForm.$data
                                });
                            };
                        }
                        /**
                           * Called when form values are saved to model.  
                           * See [editable-form demo](#editable-form) for details.
                           * 
                           * @var {method|attribute} onaftersave 
                           * @memberOf editable-form
                           * 
                           */
                        if (attrs.onaftersave) {
                            eForm.$onaftersave = function() {
                                return $parse(attrs.onaftersave)(scope, {
                                    $data: eForm.$data
                                });
                            };
                        }
                        elem.bind("submit", function(event) {
                            event.preventDefault();
                            scope.$apply(function() {
                                eForm.$submit();
                            });
                        });
                    }
                }
            };
        }
    };
} ]);

/*
Helpers
*/
/*
Collect results of function calls. Shows waiting if there are promises. 
Finally, applies callbacks if:
- onTrue(): all results are true and all promises resolved to true
- onFalse(): at least one result is false or promise resolved to false
- onString(): at least one result is string or promise rejected or promise resolved to string
*/
angular.module("xeditable").factory("editablePromiseCollection", [ "$q", function($q) {
    function promiseCollection() {
        return {
            promises: [],
            hasFalse: false,
            hasString: false,
            when: function(result, noPromise) {
                if (result === false) {
                    this.hasFalse = true;
                } else if (!noPromise && angular.isObject(result)) {
                    this.promises.push($q.when(result));
                } else if (angular.isString(result)) {
                    this.hasString = true;
                } else {
                    //result === true || result === undefined || result === null
                    return;
                }
            },
            //callbacks: onTrue, onFalse, onString
            then: function(callbacks) {
                callbacks = callbacks || {};
                var onTrue = callbacks.onTrue || angular.noop;
                var onFalse = callbacks.onFalse || angular.noop;
                var onString = callbacks.onString || angular.noop;
                var onWait = callbacks.onWait || angular.noop;
                var self = this;
                if (this.promises.length) {
                    onWait(true);
                    $q.all(this.promises).then(//all resolved       
                    function(results) {
                        onWait(false);
                        //check all results via same `when` method (without checking promises)
                        angular.forEach(results, function(result) {
                            self.when(result, true);
                        });
                        applyCallback();
                    }, //some rejected
                    function(error) {
                        onWait(false);
                        onString();
                    });
                } else {
                    applyCallback();
                }
                function applyCallback() {
                    if (!self.hasString && !self.hasFalse) {
                        onTrue();
                    } else if (!self.hasString && self.hasFalse) {
                        onFalse();
                    } else {
                        onString();
                    }
                }
            }
        };
    }
    return promiseCollection;
} ]);

angular.module("xeditable").factory("editableUtils", [ function() {
    return {
        indexOf: function(array, obj) {
            if (array.indexOf) return array.indexOf(obj);
            for (var i = 0; i < array.length; i++) {
                if (obj === array[i]) return i;
            }
            return -1;
        },
        arrayRemove: function(array, value) {
            var index = this.indexOf(array, value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return value;
        },
        // copy from https://github.com/angular/angular.js/blob/master/src/Angular.js
        camelToDash: function(str) {
            var SNAKE_CASE_REGEXP = /[A-Z]/g;
            return str.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                return (pos ? "-" : "") + letter.toLowerCase();
            });
        },
        dashToCamel: function(str) {
            var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
            var MOZ_HACK_REGEXP = /^moz([A-Z])/;
            return str.replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).replace(MOZ_HACK_REGEXP, "Moz$1");
        }
    };
} ]);

/*
Editable themes:
- default
- bootstrap 2
- bootstrap 3

Note: in postrender() `this` is instance of editableController
*/
angular.module("xeditable").factory("editableThemes", function() {
    var themes = {
        //default
        "default": {
            formTpl: '<form class="editable-wrap"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<span class="editable-controls"></span>',
            inputTpl: "",
            errorTpl: '<div class="editable-error" ng-show="$error">{{$error}}</div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit">save</button>',
            cancelTpl: '<button type="button" ng-click="$form.$cancel()">cancel</button>'
        },
        //bs2
        bs2: {
            formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',
            inputTpl: "",
            errorTpl: '<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit" class="btn btn-primary"><i class="fa fa-ok icon-white"></i></button>',
            cancelTpl: '<button type="button" class="btn" ng-click="$form.$cancel()">' + '<i class="fa fa-remove"></i>' + "</button>"
        },
        //bs3
        bs3: {
            formTpl: '<form class="form-inline editable-wrap" role="form"></form>',
            noformTpl: '<span class="editable-wrap"></span>',
            controlsTpl: '<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',
            inputTpl: "",
            errorTpl: '<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',
            buttonsTpl: '<span class="editable-buttons"></span>',
            submitTpl: '<button type="submit" class="btn btn-primary"><i class="fa fa-check"></i></button>',
            cancelTpl: '<button type="button" class="btn btn-default" ng-click="$form.$cancel()">' + '<i class="fa fa-ban"></i>' + "</button>",
            //bs3 specific prop to change buttons class: btn-sm, btn-lg
            buttonsClass: "",
            //bs3 specific prop to change standard inputs class: input-sm, input-lg
            inputClass: "",
            postrender: function() {
                //apply `form-control` class to std inputs
                switch (this.directiveName) {
                  case "editableText":
                  case "editableSelect":
                  case "editableTextarea":
                    this.inputEl.addClass("form-control");
                    if (this.theme.inputClass) {
                        // don`t apply `input-sm` and `input-lg` to select multiple
                        // should be fixed in bs itself!
                        if (this.inputEl.attr("multiple") && (this.theme.inputClass === "input-sm" || this.theme.inputClass === "input-lg")) {
                            break;
                        }
                        this.inputEl.addClass(this.theme.inputClass);
                    }
                    break;
                }
                //apply buttonsClass (bs3 specific!)
                if (this.buttonsEl && this.theme.buttonsClass) {
                    this.buttonsEl.find("button").addClass(this.theme.buttonsClass);
                }
            }
        }
    };
    return themes;
});

angular.module("ui.bootstrap", [ "ui.bootstrap.tpls", "ui.bootstrap.transition", "ui.bootstrap.collapse", "ui.bootstrap.accordion", "ui.bootstrap.alert", "ui.bootstrap.bindHtml", "ui.bootstrap.buttons", "ui.bootstrap.carousel", "ui.bootstrap.position", "ui.bootstrap.datepicker", "ui.bootstrap.dropdownToggle", "ui.bootstrap.modal", "ui.bootstrap.pagination", "ui.bootstrap.tooltip", "ui.bootstrap.popover", "ui.bootstrap.progressbar", "ui.bootstrap.rating", "ui.bootstrap.tabs", "ui.bootstrap.timepicker", "ui.bootstrap.typeahead" ]);

angular.module("ui.bootstrap.tpls", [ "template/accordion/accordion-group.html", "template/accordion/accordion.html", "template/alert/alert.html", "template/carousel/carousel.html", "template/carousel/slide.html", "template/datepicker/datepicker.html", "template/datepicker/popup.html", "template/modal/backdrop.html", "template/modal/window.html", "template/pagination/pager.html", "template/pagination/pagination.html", "template/tooltip/tooltip-html-unsafe-popup.html", "template/tooltip/tooltip-popup.html", "template/popover/popover.html", "template/progressbar/bar.html", "template/progressbar/progress.html", "template/progressbar/progressbar.html", "template/rating/rating.html", "template/tabs/tab.html", "template/tabs/tabset.html", "template/timepicker/timepicker.html", "template/typeahead/typeahead-match.html", "template/typeahead/typeahead-popup.html" ]);

angular.module("ui.bootstrap.transition", []).factory("$transition", [ "$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
    var $transition = function(element, trigger, options) {
        options = options || {};
        var deferred = $q.defer();
        var endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"];
        var transitionEndHandler = function(event) {
            $rootScope.$apply(function() {
                element.unbind(endEventName, transitionEndHandler);
                deferred.resolve(element);
            });
        };
        if (endEventName) {
            element.bind(endEventName, transitionEndHandler);
        }
        // Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
        $timeout(function() {
            if (angular.isString(trigger)) {
                element.addClass(trigger);
            } else if (angular.isFunction(trigger)) {
                trigger(element);
            } else if (angular.isObject(trigger)) {
                element.css(trigger);
            }
            //If browser does not support transitions, instantly resolve
            if (!endEventName) {
                deferred.resolve(element);
            }
        });
        // Add our custom cancel function to the promise that is returned
        // We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
        // i.e. it will therefore never raise a transitionEnd event for that transition
        deferred.promise.cancel = function() {
            if (endEventName) {
                element.unbind(endEventName, transitionEndHandler);
            }
            deferred.reject("Transition cancelled");
        };
        return deferred.promise;
    };
    // Work out the name of the transitionEnd event
    var transElement = document.createElement("trans");
    var transitionEndEventNames = {
        WebkitTransition: "webkitTransitionEnd",
        MozTransition: "transitionend",
        OTransition: "oTransitionEnd",
        transition: "transitionend"
    };
    var animationEndEventNames = {
        WebkitTransition: "webkitAnimationEnd",
        MozTransition: "animationend",
        OTransition: "oAnimationEnd",
        transition: "animationend"
    };
    function findEndEventName(endEventNames) {
        for (var name in endEventNames) {
            if (transElement.style[name] !== undefined) {
                return endEventNames[name];
            }
        }
    }
    $transition.transitionEndEventName = findEndEventName(transitionEndEventNames);
    $transition.animationEndEventName = findEndEventName(animationEndEventNames);
    return $transition;
} ]);

angular.module("ui.bootstrap.collapse", [ "ui.bootstrap.transition" ]).directive("collapse", [ "$transition", function($transition, $timeout) {
    return {
        link: function(scope, element, attrs) {
            var initialAnimSkip = true;
            var currentTransition;
            function doTransition(change) {
                var newTransition = $transition(element, change);
                if (currentTransition) {
                    currentTransition.cancel();
                }
                currentTransition = newTransition;
                newTransition.then(newTransitionDone, newTransitionDone);
                return newTransition;
                function newTransitionDone() {
                    // Make sure it's this transition, otherwise, leave it alone.
                    if (currentTransition === newTransition) {
                        currentTransition = undefined;
                    }
                }
            }
            function expand() {
                if (initialAnimSkip) {
                    initialAnimSkip = false;
                    expandDone();
                } else {
                    element.removeClass("collapse").addClass("collapsing");
                    doTransition({
                        height: element[0].scrollHeight + "px"
                    }).then(expandDone);
                }
            }
            function expandDone() {
                element.removeClass("collapsing");
                element.addClass("collapse in");
                element.css({
                    height: "auto"
                });
            }
            function collapse() {
                if (initialAnimSkip) {
                    initialAnimSkip = false;
                    collapseDone();
                    element.css({
                        height: 0
                    });
                } else {
                    // CSS transitions don't work with height: auto, so we have to manually change the height to a specific value
                    element.css({
                        height: element[0].scrollHeight + "px"
                    });
                    //trigger reflow so a browser relaizes that height was updated from auto to a specific value
                    var x = element[0].offsetWidth;
                    element.removeClass("collapse in").addClass("collapsing");
                    doTransition({
                        height: 0
                    }).then(collapseDone);
                }
            }
            function collapseDone() {
                element.removeClass("collapsing");
                element.addClass("collapse");
            }
            scope.$watch(attrs.collapse, function(shouldCollapse) {
                if (shouldCollapse) {
                    collapse();
                } else {
                    expand();
                }
            });
        }
    };
} ]);

angular.module("ui.bootstrap.accordion", [ "ui.bootstrap.collapse" ]).constant("accordionConfig", {
    closeOthers: true
}).controller("AccordionController", [ "$scope", "$attrs", "accordionConfig", function($scope, $attrs, accordionConfig) {
    // This array keeps track of the accordion groups
    this.groups = [];
    // Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
    this.closeOthers = function(openGroup) {
        var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
        if (closeOthers) {
            angular.forEach(this.groups, function(group) {
                if (group !== openGroup) {
                    group.isOpen = false;
                }
            });
        }
    };
    // This is called from the accordion-group directive to add itself to the accordion
    this.addGroup = function(groupScope) {
        var that = this;
        this.groups.push(groupScope);
        groupScope.$on("$destroy", function(event) {
            that.removeGroup(groupScope);
        });
    };
    // This is called from the accordion-group directive when to remove itself
    this.removeGroup = function(group) {
        var index = this.groups.indexOf(group);
        if (index !== -1) {
            this.groups.splice(this.groups.indexOf(group), 1);
        }
    };
} ]).directive("accordion", function() {
    return {
        restrict: "EA",
        controller: "AccordionController",
        transclude: true,
        replace: false,
        templateUrl: "template/accordion/accordion.html"
    };
}).directive("accordionGroup", [ "$parse", function($parse) {
    return {
        require: "^accordion",
        // We need this directive to be inside an accordion
        restrict: "EA",
        transclude: true,
        // It transcludes the contents of the directive into the template
        replace: true,
        // The element containing the directive will be replaced with the template
        templateUrl: "template/accordion/accordion-group.html",
        scope: {
            heading: "@"
        },
        // Create an isolated scope and interpolate the heading attribute onto this scope
        controller: function() {
            this.setHeading = function(element) {
                this.heading = element;
            };
        },
        link: function(scope, element, attrs, accordionCtrl) {
            var getIsOpen, setIsOpen;
            accordionCtrl.addGroup(scope);
            scope.isOpen = false;
            if (attrs.isOpen) {
                getIsOpen = $parse(attrs.isOpen);
                setIsOpen = getIsOpen.assign;
                scope.$parent.$watch(getIsOpen, function(value) {
                    scope.isOpen = !!value;
                });
            }
            scope.$watch("isOpen", function(value) {
                if (value) {
                    accordionCtrl.closeOthers(scope);
                }
                if (setIsOpen) {
                    setIsOpen(scope.$parent, value);
                }
            });
        }
    };
} ]).directive("accordionHeading", function() {
    return {
        restrict: "EA",
        transclude: true,
        // Grab the contents to be used as the heading
        template: "",
        // In effect remove this element!
        replace: true,
        require: "^accordionGroup",
        compile: function(element, attr, transclude) {
            return function link(scope, element, attr, accordionGroupCtrl) {
                // Pass the heading to the accordion-group controller
                // so that it can be transcluded into the right place in the template
                // [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
                accordionGroupCtrl.setHeading(transclude(scope, function() {}));
            };
        }
    };
}).directive("accordionTransclude", function() {
    return {
        require: "^accordionGroup",
        link: function(scope, element, attr, controller) {
            scope.$watch(function() {
                return controller[attr.accordionTransclude];
            }, function(heading) {
                if (heading) {
                    element.html("");
                    element.append(heading);
                }
            });
        }
    };
});

angular.module("ui.bootstrap.alert", []).controller("AlertController", [ "$scope", "$attrs", function($scope, $attrs) {
    $scope.closeable = "close" in $attrs;
} ]).directive("alert", function() {
    return {
        restrict: "EA",
        controller: "AlertController",
        templateUrl: "template/alert/alert.html",
        transclude: true,
        replace: true,
        scope: {
            type: "=",
            close: "&"
        }
    };
});

angular.module("ui.bootstrap.bindHtml", []).directive("bindHtmlUnsafe", function() {
    return function(scope, element, attr) {
        element.addClass("ng-binding").data("$binding", attr.bindHtmlUnsafe);
        scope.$watch(attr.bindHtmlUnsafe, function bindHtmlUnsafeWatchAction(value) {
            element.html(value || "");
        });
    };
});

angular.module("ui.bootstrap.buttons", []).constant("buttonConfig", {
    activeClass: "active",
    toggleEvent: "click"
}).controller("ButtonsController", [ "buttonConfig", function(buttonConfig) {
    this.activeClass = buttonConfig.activeClass || "active";
    this.toggleEvent = buttonConfig.toggleEvent || "click";
} ]).directive("btnRadio", function() {
    return {
        require: [ "btnRadio", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            //model -> UI
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.btnRadio)));
            };
            //ui->model
            element.bind(buttonsCtrl.toggleEvent, function() {
                if (!element.hasClass(buttonsCtrl.activeClass)) {
                    scope.$apply(function() {
                        ngModelCtrl.$setViewValue(scope.$eval(attrs.btnRadio));
                        ngModelCtrl.$render();
                    });
                }
            });
        }
    };
}).directive("btnCheckbox", function() {
    return {
        require: [ "btnCheckbox", "ngModel" ],
        controller: "ButtonsController",
        link: function(scope, element, attrs, ctrls) {
            var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
            function getTrueValue() {
                return getCheckboxValue(attrs.btnCheckboxTrue, true);
            }
            function getFalseValue() {
                return getCheckboxValue(attrs.btnCheckboxFalse, false);
            }
            function getCheckboxValue(attributeValue, defaultValue) {
                var val = scope.$eval(attributeValue);
                return angular.isDefined(val) ? val : defaultValue;
            }
            //model -> UI
            ngModelCtrl.$render = function() {
                element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
            };
            //ui->model
            element.bind(buttonsCtrl.toggleEvent, function() {
                scope.$apply(function() {
                    ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                    ngModelCtrl.$render();
                });
            });
        }
    };
});

/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module("ui.bootstrap.carousel", [ "ui.bootstrap.transition" ]).controller("CarouselController", [ "$scope", "$timeout", "$transition", "$q", function($scope, $timeout, $transition, $q) {
    var self = this, slides = self.slides = [], currentIndex = -1, currentTimeout, isPlaying;
    self.currentSlide = null;
    var destroyed = false;
    /* direction: "prev" or "next" */
    self.select = function(nextSlide, direction) {
        var nextIndex = slides.indexOf(nextSlide);
        //Decide direction if it's not given
        if (direction === undefined) {
            direction = nextIndex > currentIndex ? "next" : "prev";
        }
        if (nextSlide && nextSlide !== self.currentSlide) {
            if ($scope.$currentTransition) {
                $scope.$currentTransition.cancel();
                //Timeout so ng-class in template has time to fix classes for finished slide
                $timeout(goNext);
            } else {
                goNext();
            }
        }
        function goNext() {
            // Scope has been destroyed, stop here.
            if (destroyed) {
                return;
            }
            //If we have a slide to transition from and we have a transition type and we're allowed, go
            if (self.currentSlide && angular.isString(direction) && !$scope.noTransition && nextSlide.$element) {
                //We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
                nextSlide.$element.addClass(direction);
                var reflow = nextSlide.$element[0].offsetWidth;
                //force reflow
                //Set all other slides to stop doing their stuff for the new transition
                angular.forEach(slides, function(slide) {
                    angular.extend(slide, {
                        direction: "",
                        entering: false,
                        leaving: false,
                        active: false
                    });
                });
                angular.extend(nextSlide, {
                    direction: direction,
                    active: true,
                    entering: true
                });
                angular.extend(self.currentSlide || {}, {
                    direction: direction,
                    leaving: true
                });
                $scope.$currentTransition = $transition(nextSlide.$element, {});
                //We have to create new pointers inside a closure since next & current will change
                (function(next, current) {
                    $scope.$currentTransition.then(function() {
                        transitionDone(next, current);
                    }, function() {
                        transitionDone(next, current);
                    });
                })(nextSlide, self.currentSlide);
            } else {
                transitionDone(nextSlide, self.currentSlide);
            }
            self.currentSlide = nextSlide;
            currentIndex = nextIndex;
            //every time you change slides, reset the timer
            restartTimer();
        }
        function transitionDone(next, current) {
            angular.extend(next, {
                direction: "",
                active: true,
                leaving: false,
                entering: false
            });
            angular.extend(current || {}, {
                direction: "",
                active: false,
                leaving: false,
                entering: false
            });
            $scope.$currentTransition = null;
        }
    };
    $scope.$on("$destroy", function() {
        destroyed = true;
    });
    /* Allow outside people to call indexOf on slides array */
    self.indexOfSlide = function(slide) {
        return slides.indexOf(slide);
    };
    $scope.next = function() {
        var newIndex = (currentIndex + 1) % slides.length;
        //Prevent this user-triggered transition from occurring if there is already one in progress
        if (!$scope.$currentTransition) {
            return self.select(slides[newIndex], "next");
        }
    };
    $scope.prev = function() {
        var newIndex = currentIndex - 1 < 0 ? slides.length - 1 : currentIndex - 1;
        //Prevent this user-triggered transition from occurring if there is already one in progress
        if (!$scope.$currentTransition) {
            return self.select(slides[newIndex], "prev");
        }
    };
    $scope.select = function(slide) {
        self.select(slide);
    };
    $scope.isActive = function(slide) {
        return self.currentSlide === slide;
    };
    $scope.slides = function() {
        return slides;
    };
    $scope.$watch("interval", restartTimer);
    $scope.$on("$destroy", resetTimer);
    function restartTimer() {
        resetTimer();
        var interval = +$scope.interval;
        if (!isNaN(interval) && interval >= 0) {
            currentTimeout = $timeout(timerFn, interval);
        }
    }
    function resetTimer() {
        if (currentTimeout) {
            $timeout.cancel(currentTimeout);
            currentTimeout = null;
        }
    }
    function timerFn() {
        if (isPlaying) {
            $scope.next();
            restartTimer();
        } else {
            $scope.pause();
        }
    }
    $scope.play = function() {
        if (!isPlaying) {
            isPlaying = true;
            restartTimer();
        }
    };
    $scope.pause = function() {
        if (!$scope.noPause) {
            isPlaying = false;
            resetTimer();
        }
    };
    self.addSlide = function(slide, element) {
        slide.$element = element;
        slides.push(slide);
        //if this is the first slide or the slide is set to active, select it
        if (slides.length === 1 || slide.active) {
            self.select(slides[slides.length - 1]);
            if (slides.length == 1) {
                $scope.play();
            }
        } else {
            slide.active = false;
        }
    };
    self.removeSlide = function(slide) {
        //get the index of the slide inside the carousel
        var index = slides.indexOf(slide);
        slides.splice(index, 1);
        if (slides.length > 0 && slide.active) {
            if (index >= slides.length) {
                self.select(slides[index - 1]);
            } else {
                self.select(slides[index]);
            }
        } else if (currentIndex > index) {
            currentIndex--;
        }
    };
} ]).directive("carousel", [ function() {
    return {
        restrict: "EA",
        transclude: true,
        replace: true,
        controller: "CarouselController",
        require: "carousel",
        templateUrl: "template/carousel/carousel.html",
        scope: {
            interval: "=",
            noTransition: "=",
            noPause: "="
        }
    };
} ]).directive("slide", [ "$parse", function($parse) {
    return {
        require: "^carousel",
        restrict: "EA",
        transclude: true,
        replace: true,
        templateUrl: "template/carousel/slide.html",
        scope: {},
        link: function(scope, element, attrs, carouselCtrl) {
            //Set up optional 'active' = binding
            if (attrs.active) {
                var getActive = $parse(attrs.active);
                var setActive = getActive.assign;
                var lastValue = scope.active = getActive(scope.$parent);
                scope.$watch(function parentActiveWatch() {
                    var parentActive = getActive(scope.$parent);
                    if (parentActive !== scope.active) {
                        // we are out of sync and need to copy
                        if (parentActive !== lastValue) {
                            // parent changed and it has precedence
                            lastValue = scope.active = parentActive;
                        } else {
                            // if the parent can be assigned then do so
                            setActive(scope.$parent, parentActive = lastValue = scope.active);
                        }
                    }
                    return parentActive;
                });
            }
            carouselCtrl.addSlide(scope, element);
            //when the scope is destroyed then remove the slide from the current slides array
            scope.$on("$destroy", function() {
                carouselCtrl.removeSlide(scope);
            });
            scope.$watch("active", function(active) {
                if (active) {
                    carouselCtrl.select(scope);
                }
            });
        }
    };
} ]);

angular.module("ui.bootstrap.position", []).factory("$position", [ "$document", "$window", function($document, $window) {
    function getStyle(el, cssprop) {
        if (el.currentStyle) {
            //IE
            return el.currentStyle[cssprop];
        } else if ($window.getComputedStyle) {
            return $window.getComputedStyle(el)[cssprop];
        }
        // finally try and get inline style
        return el.style[cssprop];
    }
    /**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
    function isStaticPositioned(element) {
        return (getStyle(element, "position") || "static") === "static";
    }
    /**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
    var parentOffsetEl = function(element) {
        var docDomEl = $document[0];
        var offsetParent = element.offsetParent || docDomEl;
        while (offsetParent && offsetParent !== docDomEl && isStaticPositioned(offsetParent)) {
            offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docDomEl;
    };
    return {
        /**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
        position: function(element) {
            var elBCR = this.offset(element);
            var offsetParentBCR = {
                top: 0,
                left: 0
            };
            var offsetParentEl = parentOffsetEl(element[0]);
            if (offsetParentEl != $document[0]) {
                offsetParentBCR = this.offset(angular.element(offsetParentEl));
                offsetParentBCR.top += offsetParentEl.clientTop - offsetParentEl.scrollTop;
                offsetParentBCR.left += offsetParentEl.clientLeft - offsetParentEl.scrollLeft;
            }
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: elBCR.top - offsetParentBCR.top,
                left: elBCR.left - offsetParentBCR.left
            };
        },
        /**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
        offset: function(element) {
            var boundingClientRect = element[0].getBoundingClientRect();
            return {
                width: boundingClientRect.width || element.prop("offsetWidth"),
                height: boundingClientRect.height || element.prop("offsetHeight"),
                top: boundingClientRect.top + ($window.pageYOffset || $document[0].body.scrollTop || $document[0].documentElement.scrollTop),
                left: boundingClientRect.left + ($window.pageXOffset || $document[0].body.scrollLeft || $document[0].documentElement.scrollLeft)
            };
        }
    };
} ]);

angular.module("ui.bootstrap.datepicker", [ "ui.bootstrap.position" ]).constant("datepickerConfig", {
    dayFormat: "dd",
    monthFormat: "MMMM",
    yearFormat: "yyyy",
    dayHeaderFormat: "EEE",
    dayTitleFormat: "MMMM yyyy",
    monthTitleFormat: "yyyy",
    showWeeks: true,
    startingDay: 0,
    yearRange: 20,
    minDate: null,
    maxDate: null
}).controller("DatepickerController", [ "$scope", "$attrs", "dateFilter", "datepickerConfig", function($scope, $attrs, dateFilter, dtConfig) {
    var format = {
        day: getValue($attrs.dayFormat, dtConfig.dayFormat),
        month: getValue($attrs.monthFormat, dtConfig.monthFormat),
        year: getValue($attrs.yearFormat, dtConfig.yearFormat),
        dayHeader: getValue($attrs.dayHeaderFormat, dtConfig.dayHeaderFormat),
        dayTitle: getValue($attrs.dayTitleFormat, dtConfig.dayTitleFormat),
        monthTitle: getValue($attrs.monthTitleFormat, dtConfig.monthTitleFormat)
    }, startingDay = getValue($attrs.startingDay, dtConfig.startingDay), yearRange = getValue($attrs.yearRange, dtConfig.yearRange);
    this.minDate = dtConfig.minDate ? new Date(dtConfig.minDate) : null;
    this.maxDate = dtConfig.maxDate ? new Date(dtConfig.maxDate) : null;
    function getValue(value, defaultValue) {
        return angular.isDefined(value) ? $scope.$parent.$eval(value) : defaultValue;
    }
    function getDaysInMonth(year, month) {
        return new Date(year, month, 0).getDate();
    }
    function getDates(startDate, n) {
        var dates = new Array(n);
        var current = startDate, i = 0;
        while (i < n) {
            dates[i++] = new Date(current);
            current.setDate(current.getDate() + 1);
        }
        return dates;
    }
    function makeDate(date, format, isSelected, isSecondary) {
        return {
            date: date,
            label: dateFilter(date, format),
            selected: !!isSelected,
            secondary: !!isSecondary
        };
    }
    this.modes = [ {
        name: "day",
        getVisibleDates: function(date, selected) {
            var year = date.getFullYear(), month = date.getMonth(), firstDayOfMonth = new Date(year, month, 1);
            var difference = startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth), numDates = 0;
            if (numDisplayedFromPreviousMonth > 0) {
                firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
                numDates += numDisplayedFromPreviousMonth;
            }
            numDates += getDaysInMonth(year, month + 1);
            // Current
            numDates += (7 - numDates % 7) % 7;
            // Next
            var days = getDates(firstDate, numDates), labels = new Array(7);
            for (var i = 0; i < numDates; i++) {
                var dt = new Date(days[i]);
                days[i] = makeDate(dt, format.day, selected && selected.getDate() === dt.getDate() && selected.getMonth() === dt.getMonth() && selected.getFullYear() === dt.getFullYear(), dt.getMonth() !== month);
            }
            for (var j = 0; j < 7; j++) {
                labels[j] = dateFilter(days[j].date, format.dayHeader);
            }
            return {
                objects: days,
                title: dateFilter(date, format.dayTitle),
                labels: labels
            };
        },
        compare: function(date1, date2) {
            return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
        },
        split: 7,
        step: {
            months: 1
        }
    }, {
        name: "month",
        getVisibleDates: function(date, selected) {
            var months = new Array(12), year = date.getFullYear();
            for (var i = 0; i < 12; i++) {
                var dt = new Date(year, i, 1);
                months[i] = makeDate(dt, format.month, selected && selected.getMonth() === i && selected.getFullYear() === year);
            }
            return {
                objects: months,
                title: dateFilter(date, format.monthTitle)
            };
        },
        compare: function(date1, date2) {
            return new Date(date1.getFullYear(), date1.getMonth()) - new Date(date2.getFullYear(), date2.getMonth());
        },
        split: 3,
        step: {
            years: 1
        }
    }, {
        name: "year",
        getVisibleDates: function(date, selected) {
            var years = new Array(yearRange), year = date.getFullYear(), startYear = parseInt((year - 1) / yearRange, 10) * yearRange + 1;
            for (var i = 0; i < yearRange; i++) {
                var dt = new Date(startYear + i, 0, 1);
                years[i] = makeDate(dt, format.year, selected && selected.getFullYear() === dt.getFullYear());
            }
            return {
                objects: years,
                title: [ years[0].label, years[yearRange - 1].label ].join(" - ")
            };
        },
        compare: function(date1, date2) {
            return date1.getFullYear() - date2.getFullYear();
        },
        split: 5,
        step: {
            years: yearRange
        }
    } ];
    this.isDisabled = function(date, mode) {
        var currentMode = this.modes[mode || 0];
        return this.minDate && currentMode.compare(date, this.minDate) < 0 || this.maxDate && currentMode.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
            date: date,
            mode: currentMode.name
        });
    };
} ]).directive("datepicker", [ "dateFilter", "$parse", "datepickerConfig", "$log", function(dateFilter, $parse, datepickerConfig, $log) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/datepicker/datepicker.html",
        scope: {
            dateDisabled: "&"
        },
        require: [ "datepicker", "?^ngModel" ],
        controller: "DatepickerController",
        link: function(scope, element, attrs, ctrls) {
            var datepickerCtrl = ctrls[0], ngModel = ctrls[1];
            if (!ngModel) {
                return;
            }
            // Configuration parameters
            var mode = 0, selected = new Date(), showWeeks = datepickerConfig.showWeeks;
            if (attrs.showWeeks) {
                scope.$parent.$watch($parse(attrs.showWeeks), function(value) {
                    showWeeks = !!value;
                    updateShowWeekNumbers();
                });
            } else {
                updateShowWeekNumbers();
            }
            if (attrs.min) {
                scope.$parent.$watch($parse(attrs.min), function(value) {
                    datepickerCtrl.minDate = value ? new Date(value) : null;
                    refill();
                });
            }
            if (attrs.max) {
                scope.$parent.$watch($parse(attrs.max), function(value) {
                    datepickerCtrl.maxDate = value ? new Date(value) : null;
                    refill();
                });
            }
            function updateShowWeekNumbers() {
                scope.showWeekNumbers = mode === 0 && showWeeks;
            }
            // Split array into smaller arrays
            function split(arr, size) {
                var arrays = [];
                while (arr.length > 0) {
                    arrays.push(arr.splice(0, size));
                }
                return arrays;
            }
            function refill(updateSelected) {
                var date = null, valid = true;
                if (ngModel.$modelValue) {
                    date = new Date(ngModel.$modelValue);
                    if (isNaN(date)) {
                        valid = false;
                        $log.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
                    } else if (updateSelected) {
                        selected = date;
                    }
                }
                ngModel.$setValidity("date", valid);
                var currentMode = datepickerCtrl.modes[mode], data = currentMode.getVisibleDates(selected, date);
                angular.forEach(data.objects, function(obj) {
                    obj.disabled = datepickerCtrl.isDisabled(obj.date, mode);
                });
                ngModel.$setValidity("date-disabled", !date || !datepickerCtrl.isDisabled(date));
                scope.rows = split(data.objects, currentMode.split);
                scope.labels = data.labels || [];
                scope.title = data.title;
            }
            function setMode(value) {
                mode = value;
                updateShowWeekNumbers();
                refill();
            }
            ngModel.$render = function() {
                refill(true);
            };
            scope.select = function(date) {
                if (mode === 0) {
                    var dt = ngModel.$modelValue ? new Date(ngModel.$modelValue) : new Date(0, 0, 0, 0, 0, 0, 0);
                    dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                    ngModel.$setViewValue(dt);
                    refill(true);
                } else {
                    selected = date;
                    setMode(mode - 1);
                }
            };
            scope.move = function(direction) {
                var step = datepickerCtrl.modes[mode].step;
                selected.setMonth(selected.getMonth() + direction * (step.months || 0));
                selected.setFullYear(selected.getFullYear() + direction * (step.years || 0));
                refill();
            };
            scope.toggleMode = function() {
                setMode((mode + 1) % datepickerCtrl.modes.length);
            };
            scope.getWeekNumber = function(row) {
                return mode === 0 && scope.showWeekNumbers && row.length === 7 ? getISO8601WeekNumber(row[0].date) : null;
            };
            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                // Thursday
                var time = checkDate.getTime();
                checkDate.setMonth(0);
                // Compare with Jan 1
                checkDate.setDate(1);
                return Math.floor(Math.round((time - checkDate) / 864e5) / 7) + 1;
            }
        }
    };
} ]).constant("datepickerPopupConfig", {
    dateFormat: "yyyy-MM-dd",
    currentText: "Today",
    toggleWeeksText: "Weeks",
    clearText: "Clear",
    closeText: "Done",
    closeOnDateSelection: true,
    appendToBody: false,
    showButtonBar: true
}).directive("datepickerPopup", [ "$compile", "$parse", "$document", "$position", "dateFilter", "datepickerPopupConfig", "datepickerConfig", function($compile, $parse, $document, $position, dateFilter, datepickerPopupConfig, datepickerConfig) {
    return {
        restrict: "EA",
        require: "ngModel",
        link: function(originalScope, element, attrs, ngModel) {
            var scope = originalScope.$new(), // create a child scope so we are not polluting original one
            dateFormat, closeOnDateSelection = angular.isDefined(attrs.closeOnDateSelection) ? originalScope.$eval(attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection, appendToBody = angular.isDefined(attrs.datepickerAppendToBody) ? originalScope.$eval(attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
            attrs.$observe("datepickerPopup", function(value) {
                dateFormat = value || datepickerPopupConfig.dateFormat;
                ngModel.$render();
            });
            scope.showButtonBar = angular.isDefined(attrs.showButtonBar) ? originalScope.$eval(attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
            originalScope.$on("$destroy", function() {
                $popup.remove();
                scope.$destroy();
            });
            attrs.$observe("currentText", function(text) {
                scope.currentText = angular.isDefined(text) ? text : datepickerPopupConfig.currentText;
            });
            attrs.$observe("toggleWeeksText", function(text) {
                scope.toggleWeeksText = angular.isDefined(text) ? text : datepickerPopupConfig.toggleWeeksText;
            });
            attrs.$observe("clearText", function(text) {
                scope.clearText = angular.isDefined(text) ? text : datepickerPopupConfig.clearText;
            });
            attrs.$observe("closeText", function(text) {
                scope.closeText = angular.isDefined(text) ? text : datepickerPopupConfig.closeText;
            });
            var getIsOpen, setIsOpen;
            if (attrs.isOpen) {
                getIsOpen = $parse(attrs.isOpen);
                setIsOpen = getIsOpen.assign;
                originalScope.$watch(getIsOpen, function updateOpen(value) {
                    scope.isOpen = !!value;
                });
            }
            scope.isOpen = getIsOpen ? getIsOpen(originalScope) : false;
            // Initial state
            function setOpen(value) {
                if (setIsOpen) {
                    setIsOpen(originalScope, !!value);
                } else {
                    scope.isOpen = !!value;
                }
            }
            var documentClickBind = function(event) {
                if (scope.isOpen && event.target !== element[0]) {
                    scope.$apply(function() {
                        setOpen(false);
                    });
                }
            };
            var elementFocusBind = function() {
                scope.$apply(function() {
                    setOpen(true);
                });
            };
            // popup element used to display calendar
            var popupEl = angular.element("<div datepicker-popup-wrap><div datepicker></div></div>");
            popupEl.attr({
                "ng-model": "date",
                "ng-change": "dateSelection()"
            });
            var datepickerEl = angular.element(popupEl.children()[0]);
            if (attrs.datepickerOptions) {
                datepickerEl.attr(angular.extend({}, originalScope.$eval(attrs.datepickerOptions)));
            }
            // TODO: reverse from dateFilter string to Date object
            function parseDate(viewValue) {
                if (!viewValue) {
                    ngModel.$setValidity("date", true);
                    return null;
                } else if (angular.isDate(viewValue)) {
                    ngModel.$setValidity("date", true);
                    return viewValue;
                } else if (angular.isString(viewValue)) {
                    var date = new Date(viewValue);
                    if (isNaN(date)) {
                        ngModel.$setValidity("date", false);
                        return undefined;
                    } else {
                        ngModel.$setValidity("date", true);
                        return date;
                    }
                } else {
                    ngModel.$setValidity("date", false);
                    return undefined;
                }
            }
            ngModel.$parsers.unshift(parseDate);
            // Inner change
            scope.dateSelection = function(dt) {
                if (angular.isDefined(dt)) {
                    scope.date = dt;
                }
                ngModel.$setViewValue(scope.date);
                ngModel.$render();
                if (closeOnDateSelection) {
                    setOpen(false);
                }
            };
            element.bind("input change keyup", function() {
                scope.$apply(function() {
                    scope.date = ngModel.$modelValue;
                });
            });
            // Outter change
            ngModel.$render = function() {
                var date = ngModel.$viewValue ? dateFilter(ngModel.$viewValue, dateFormat) : "";
                element.val(date);
                scope.date = ngModel.$modelValue;
            };
            function addWatchableAttribute(attribute, scopeProperty, datepickerAttribute) {
                if (attribute) {
                    originalScope.$watch($parse(attribute), function(value) {
                        scope[scopeProperty] = value;
                    });
                    datepickerEl.attr(datepickerAttribute || scopeProperty, scopeProperty);
                }
            }
            addWatchableAttribute(attrs.min, "min");
            addWatchableAttribute(attrs.max, "max");
            if (attrs.showWeeks) {
                addWatchableAttribute(attrs.showWeeks, "showWeeks", "show-weeks");
            } else {
                scope.showWeeks = datepickerConfig.showWeeks;
                datepickerEl.attr("show-weeks", "showWeeks");
            }
            if (attrs.dateDisabled) {
                datepickerEl.attr("date-disabled", attrs.dateDisabled);
            }
            function updatePosition() {
                scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                scope.position.top = scope.position.top + element.prop("offsetHeight");
            }
            var documentBindingInitialized = false, elementFocusInitialized = false;
            scope.$watch("isOpen", function(value) {
                if (value) {
                    updatePosition();
                    $document.bind("click", documentClickBind);
                    if (elementFocusInitialized) {
                        element.unbind("focus", elementFocusBind);
                    }
                    element[0].focus();
                    documentBindingInitialized = true;
                } else {
                    if (documentBindingInitialized) {
                        $document.unbind("click", documentClickBind);
                    }
                    element.bind("focus", elementFocusBind);
                    elementFocusInitialized = true;
                }
                if (setIsOpen) {
                    setIsOpen(originalScope, value);
                }
            });
            scope.today = function() {
                scope.dateSelection(new Date());
            };
            scope.clear = function() {
                scope.dateSelection(null);
            };
            var $popup = $compile(popupEl)(scope);
            if (appendToBody) {
                $document.find("body").append($popup);
            } else {
                element.after($popup);
            }
        }
    };
} ]).directive("datepickerPopupWrap", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        templateUrl: "template/datepicker/popup.html",
        link: function(scope, element, attrs) {
            element.bind("click", function(event) {
                event.preventDefault();
                event.stopPropagation();
            });
        }
    };
});

/*
 * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js
 * @restrict class or attribute
 * @example:
   <li class="dropdown">
     <a class="dropdown-toggle">My Dropdown Menu</a>
     <ul class="dropdown-menu">
       <li ng-repeat="choice in dropChoices">
         <a ng-href="{{choice.href}}">{{choice.text}}</a>
       </li>
     </ul>
   </li>
 */
angular.module("ui.bootstrap.dropdownToggle", []).directive("dropdownToggle", [ "$document", "$location", function($document, $location) {
    var openElement = null, closeMenu = angular.noop;
    return {
        restrict: "CA",
        link: function(scope, element, attrs) {
            scope.$watch("$location.path", function() {
                closeMenu();
            });
            element.parent().bind("click", function() {
                closeMenu();
            });
            element.bind("click", function(event) {
                var elementWasOpen = element === openElement;
                event.preventDefault();
                event.stopPropagation();
                if (!!openElement) {
                    closeMenu();
                }
                if (!elementWasOpen && !element.hasClass("disabled") && !element.prop("disabled")) {
                    element.parent().addClass("open");
                    openElement = element;
                    closeMenu = function(event) {
                        if (event) {
                            event.preventDefault();
                            event.stopPropagation();
                        }
                        $document.unbind("click", closeMenu);
                        element.parent().removeClass("open");
                        closeMenu = angular.noop;
                        openElement = null;
                    };
                    $document.bind("click", closeMenu);
                }
            });
        }
    };
} ]);

angular.module("ui.bootstrap.modal", []).factory("$$stackedMap", function() {
    return {
        createNew: function() {
            var stack = [];
            return {
                add: function(key, value) {
                    stack.push({
                        key: key,
                        value: value
                    });
                },
                get: function(key) {
                    for (var i = 0; i < stack.length; i++) {
                        if (key == stack[i].key) {
                            return stack[i];
                        }
                    }
                },
                keys: function() {
                    var keys = [];
                    for (var i = 0; i < stack.length; i++) {
                        keys.push(stack[i].key);
                    }
                    return keys;
                },
                top: function() {
                    return stack[stack.length - 1];
                },
                remove: function(key) {
                    var idx = -1;
                    for (var i = 0; i < stack.length; i++) {
                        if (key == stack[i].key) {
                            idx = i;
                            break;
                        }
                    }
                    return stack.splice(idx, 1)[0];
                },
                removeTop: function() {
                    return stack.splice(stack.length - 1, 1)[0];
                },
                length: function() {
                    return stack.length;
                }
            };
        }
    };
}).directive("modalBackdrop", [ "$timeout", function($timeout) {
    return {
        restrict: "EA",
        replace: true,
        templateUrl: "template/modal/backdrop.html",
        link: function(scope) {
            scope.animate = false;
            //trigger CSS transitions
            $timeout(function() {
                scope.animate = true;
            });
        }
    };
} ]).directive("modalWindow", [ "$modalStack", "$timeout", function($modalStack, $timeout) {
    return {
        restrict: "EA",
        scope: {
            index: "@"
        },
        replace: true,
        transclude: true,
        templateUrl: "template/modal/window.html",
        link: function(scope, element, attrs) {
            scope.windowClass = attrs.windowClass || "";
            $timeout(function() {
                // trigger CSS transitions
                scope.animate = true;
                // focus a freshly-opened modal
                element[0].focus();
            });
            scope.close = function(evt) {
                var modal = $modalStack.getTop();
                if (modal && modal.value.backdrop && modal.value.backdrop != "static" && evt.target === evt.currentTarget) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    $modalStack.dismiss(modal.key, "backdrop click");
                }
            };
        }
    };
} ]).factory("$modalStack", [ "$document", "$compile", "$rootScope", "$$stackedMap", function($document, $compile, $rootScope, $$stackedMap) {
    var OPENED_MODAL_CLASS = "modal-open";
    var backdropjqLiteEl, backdropDomEl;
    var backdropScope = $rootScope.$new(true);
    var openedWindows = $$stackedMap.createNew();
    var $modalStack = {};
    function backdropIndex() {
        var topBackdropIndex = -1;
        var opened = openedWindows.keys();
        for (var i = 0; i < opened.length; i++) {
            if (openedWindows.get(opened[i]).value.backdrop) {
                topBackdropIndex = i;
            }
        }
        return topBackdropIndex;
    }
    $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
        backdropScope.index = newBackdropIndex;
    });
    function removeModalWindow(modalInstance) {
        var body = $document.find("body").eq(0);
        var modalWindow = openedWindows.get(modalInstance).value;
        //clean up the stack
        openedWindows.remove(modalInstance);
        //remove window DOM element
        modalWindow.modalDomEl.remove();
        body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0);
        //remove backdrop if no longer needed
        if (backdropDomEl && backdropIndex() == -1) {
            backdropDomEl.remove();
            backdropDomEl = undefined;
        }
        //destroy scope
        modalWindow.modalScope.$destroy();
    }
    $document.bind("keydown", function(evt) {
        var modal;
        if (evt.which === 27) {
            modal = openedWindows.top();
            if (modal && modal.value.keyboard) {
                $rootScope.$apply(function() {
                    $modalStack.dismiss(modal.key);
                });
            }
        }
    });
    $modalStack.open = function(modalInstance, modal) {
        openedWindows.add(modalInstance, {
            deferred: modal.deferred,
            modalScope: modal.scope,
            backdrop: modal.backdrop,
            keyboard: modal.keyboard
        });
        var body = $document.find("body").eq(0);
        if (backdropIndex() >= 0 && !backdropDomEl) {
            backdropjqLiteEl = angular.element("<div modal-backdrop></div>");
            backdropDomEl = $compile(backdropjqLiteEl)(backdropScope);
            body.append(backdropDomEl);
        }
        var angularDomEl = angular.element("<div modal-window></div>");
        angularDomEl.attr("window-class", modal.windowClass);
        angularDomEl.attr("index", openedWindows.length() - 1);
        angularDomEl.html(modal.content);
        var modalDomEl = $compile(angularDomEl)(modal.scope);
        openedWindows.top().value.modalDomEl = modalDomEl;
        body.append(modalDomEl);
        body.addClass(OPENED_MODAL_CLASS);
    };
    $modalStack.close = function(modalInstance, result) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
            modalWindow.deferred.resolve(result);
            removeModalWindow(modalInstance);
        }
    };
    $modalStack.dismiss = function(modalInstance, reason) {
        var modalWindow = openedWindows.get(modalInstance).value;
        if (modalWindow) {
            modalWindow.deferred.reject(reason);
            removeModalWindow(modalInstance);
        }
    };
    $modalStack.getTop = function() {
        return openedWindows.top();
    };
    return $modalStack;
} ]).provider("$modal", function() {
    var $modalProvider = {
        options: {
            backdrop: true,
            //can be also false or 'static'
            keyboard: true
        },
        $get: [ "$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
            var $modal = {};
            function getTemplatePromise(options) {
                return options.template ? $q.when(options.template) : $http.get(options.templateUrl, {
                    cache: $templateCache
                }).then(function(result) {
                    return result.data;
                });
            }
            function getResolvePromises(resolves) {
                var promisesArr = [];
                angular.forEach(resolves, function(value, key) {
                    if (angular.isFunction(value) || angular.isArray(value)) {
                        promisesArr.push($q.when($injector.invoke(value)));
                    }
                });
                return promisesArr;
            }
            $modal.open = function(modalOptions) {
                var modalResultDeferred = $q.defer();
                var modalOpenedDeferred = $q.defer();
                //prepare an instance of a modal to be injected into controllers and returned to a caller
                var modalInstance = {
                    result: modalResultDeferred.promise,
                    opened: modalOpenedDeferred.promise,
                    close: function(result) {
                        $modalStack.close(modalInstance, result);
                    },
                    dismiss: function(reason) {
                        $modalStack.dismiss(modalInstance, reason);
                    }
                };
                //merge and clean up options
                modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
                modalOptions.resolve = modalOptions.resolve || {};
                //verify options
                if (!modalOptions.template && !modalOptions.templateUrl) {
                    throw new Error("One of template or templateUrl options is required.");
                }
                var templateAndResolvePromise = $q.all([ getTemplatePromise(modalOptions) ].concat(getResolvePromises(modalOptions.resolve)));
                templateAndResolvePromise.then(function resolveSuccess(tplAndVars) {
                    var modalScope = (modalOptions.scope || $rootScope).$new();
                    modalScope.$close = modalInstance.close;
                    modalScope.$dismiss = modalInstance.dismiss;
                    var ctrlInstance, ctrlLocals = {};
                    var resolveIter = 1;
                    //controllers
                    if (modalOptions.controller) {
                        ctrlLocals.$scope = modalScope;
                        ctrlLocals.$modalInstance = modalInstance;
                        angular.forEach(modalOptions.resolve, function(value, key) {
                            ctrlLocals[key] = tplAndVars[resolveIter++];
                        });
                        ctrlInstance = $controller(modalOptions.controller, ctrlLocals);
                    }
                    $modalStack.open(modalInstance, {
                        scope: modalScope,
                        deferred: modalResultDeferred,
                        content: tplAndVars[0],
                        backdrop: modalOptions.backdrop,
                        keyboard: modalOptions.keyboard,
                        windowClass: modalOptions.windowClass
                    });
                }, function resolveError(reason) {
                    modalResultDeferred.reject(reason);
                });
                templateAndResolvePromise.then(function() {
                    modalOpenedDeferred.resolve(true);
                }, function() {
                    modalOpenedDeferred.reject(false);
                });
                return modalInstance;
            };
            return $modal;
        } ]
    };
    return $modalProvider;
});

angular.module("ui.bootstrap.pagination", []).controller("PaginationController", [ "$scope", "$attrs", "$parse", "$interpolate", function($scope, $attrs, $parse, $interpolate) {
    var self = this, setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
    this.init = function(defaultItemsPerPage) {
        if ($attrs.itemsPerPage) {
            $scope.$parent.$watch($parse($attrs.itemsPerPage), function(value) {
                self.itemsPerPage = parseInt(value, 10);
                $scope.totalPages = self.calculateTotalPages();
            });
        } else {
            this.itemsPerPage = defaultItemsPerPage;
        }
    };
    this.noPrevious = function() {
        return this.page === 1;
    };
    this.noNext = function() {
        return this.page === $scope.totalPages;
    };
    this.isActive = function(page) {
        return this.page === page;
    };
    this.calculateTotalPages = function() {
        var totalPages = this.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / this.itemsPerPage);
        return Math.max(totalPages || 0, 1);
    };
    this.getAttributeValue = function(attribute, defaultValue, interpolate) {
        return angular.isDefined(attribute) ? interpolate ? $interpolate(attribute)($scope.$parent) : $scope.$parent.$eval(attribute) : defaultValue;
    };
    this.render = function() {
        this.page = parseInt($scope.page, 10) || 1;
        if (this.page > 0 && this.page <= $scope.totalPages) {
            $scope.pages = this.getPages(this.page, $scope.totalPages);
        }
    };
    $scope.selectPage = function(page) {
        if (!self.isActive(page) && page > 0 && page <= $scope.totalPages) {
            $scope.page = page;
            $scope.onSelectPage({
                page: page
            });
        }
    };
    $scope.$watch("page", function() {
        self.render();
    });
    $scope.$watch("totalItems", function() {
        $scope.totalPages = self.calculateTotalPages();
    });
    $scope.$watch("totalPages", function(value) {
        setNumPages($scope.$parent, value);
        // Readonly variable
        if (self.page > value) {
            $scope.selectPage(value);
        } else {
            self.render();
        }
    });
} ]).constant("paginationConfig", {
    itemsPerPage: 10,
    boundaryLinks: false,
    directionLinks: true,
    firstText: "First",
    previousText: "Previous",
    nextText: "Next",
    lastText: "Last",
    rotate: true
}).directive("pagination", [ "$parse", "paginationConfig", function($parse, config) {
    return {
        restrict: "EA",
        scope: {
            page: "=",
            totalItems: "=",
            onSelectPage: " &"
        },
        controller: "PaginationController",
        templateUrl: "template/pagination/pagination.html",
        replace: true,
        link: function(scope, element, attrs, paginationCtrl) {
            // Setup configuration parameters
            var maxSize, boundaryLinks = paginationCtrl.getAttributeValue(attrs.boundaryLinks, config.boundaryLinks), directionLinks = paginationCtrl.getAttributeValue(attrs.directionLinks, config.directionLinks), firstText = paginationCtrl.getAttributeValue(attrs.firstText, config.firstText, true), previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true), lastText = paginationCtrl.getAttributeValue(attrs.lastText, config.lastText, true), rotate = paginationCtrl.getAttributeValue(attrs.rotate, config.rotate);
            paginationCtrl.init(config.itemsPerPage);
            if (attrs.maxSize) {
                scope.$parent.$watch($parse(attrs.maxSize), function(value) {
                    maxSize = parseInt(value, 10);
                    paginationCtrl.render();
                });
            }
            // Create page object used in template
            function makePage(number, text, isActive, isDisabled) {
                return {
                    number: number,
                    text: text,
                    active: isActive,
                    disabled: isDisabled
                };
            }
            paginationCtrl.getPages = function(currentPage, totalPages) {
                var pages = [];
                // Default page limits
                var startPage = 1, endPage = totalPages;
                var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
                // recompute if maxSize
                if (isMaxSized) {
                    if (rotate) {
                        // Current page is displayed in the middle of the visible ones
                        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                        endPage = startPage + maxSize - 1;
                        // Adjust if limit is exceeded
                        if (endPage > totalPages) {
                            endPage = totalPages;
                            startPage = endPage - maxSize + 1;
                        }
                    } else {
                        // Visible pages are paginated with maxSize
                        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
                        // Adjust last page if limit is exceeded
                        endPage = Math.min(startPage + maxSize - 1, totalPages);
                    }
                }
                // Add page number links
                for (var number = startPage; number <= endPage; number++) {
                    var page = makePage(number, number, paginationCtrl.isActive(number), false);
                    pages.push(page);
                }
                // Add links to move between page sets
                if (isMaxSized && !rotate) {
                    if (startPage > 1) {
                        var previousPageSet = makePage(startPage - 1, "...", false, false);
                        pages.unshift(previousPageSet);
                    }
                    if (endPage < totalPages) {
                        var nextPageSet = makePage(endPage + 1, "...", false, false);
                        pages.push(nextPageSet);
                    }
                }
                // Add previous & next links
                if (directionLinks) {
                    var previousPage = makePage(currentPage - 1, previousText, false, paginationCtrl.noPrevious());
                    pages.unshift(previousPage);
                    var nextPage = makePage(currentPage + 1, nextText, false, paginationCtrl.noNext());
                    pages.push(nextPage);
                }
                // Add first & last links
                if (boundaryLinks) {
                    var firstPage = makePage(1, firstText, false, paginationCtrl.noPrevious());
                    pages.unshift(firstPage);
                    var lastPage = makePage(totalPages, lastText, false, paginationCtrl.noNext());
                    pages.push(lastPage);
                }
                return pages;
            };
        }
    };
} ]).constant("pagerConfig", {
    itemsPerPage: 10,
    previousText: " Previous",
    nextText: "Next ",
    align: true
}).directive("pager", [ "pagerConfig", function(config) {
    return {
        restrict: "EA",
        scope: {
            page: "=",
            totalItems: "=",
            onSelectPage: " &"
        },
        controller: "PaginationController",
        templateUrl: "template/pagination/pager.html",
        replace: true,
        link: function(scope, element, attrs, paginationCtrl) {
            // Setup configuration parameters
            var previousText = paginationCtrl.getAttributeValue(attrs.previousText, config.previousText, true), nextText = paginationCtrl.getAttributeValue(attrs.nextText, config.nextText, true), align = paginationCtrl.getAttributeValue(attrs.align, config.align);
            paginationCtrl.init(config.itemsPerPage);
            // Create page object used in template
            function makePage(number, text, isDisabled, isPrevious, isNext) {
                return {
                    number: number,
                    text: text,
                    disabled: isDisabled,
                    previous: align && isPrevious,
                    next: align && isNext
                };
            }
            paginationCtrl.getPages = function(currentPage) {
                return [ makePage(currentPage - 1, previousText, paginationCtrl.noPrevious(), true, false), makePage(currentPage + 1, nextText, paginationCtrl.noNext(), false, true) ];
            };
        }
    };
} ]);

/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module("ui.bootstrap.tooltip", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).provider("$tooltip", function() {
    // The default options tooltip and popover.
    var defaultOptions = {
        placement: "top",
        animation: true,
        popupDelay: 0
    };
    // Default hide triggers for each show trigger
    var triggerMap = {
        mouseenter: "mouseleave",
        click: "click",
        focus: "blur"
    };
    // The options specified to the provider globally.
    var globalOptions = {};
    /**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
    this.options = function(value) {
        angular.extend(globalOptions, value);
    };
    /**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
    this.setTriggers = function setTriggers(triggers) {
        angular.extend(triggerMap, triggers);
    };
    /**
   * This is a helper function for translating camel-case to snake-case.
   */
    function snake_case(name) {
        var regexp = /[A-Z]/g;
        var separator = "-";
        return name.replace(regexp, function(letter, pos) {
            return (pos ? separator : "") + letter.toLowerCase();
        });
    }
    /**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
    this.$get = [ "$window", "$compile", "$timeout", "$parse", "$document", "$position", "$interpolate", function($window, $compile, $timeout, $parse, $document, $position, $interpolate) {
        return function $tooltip(type, prefix, defaultTriggerShow) {
            var options = angular.extend({}, defaultOptions, globalOptions);
            /**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
            function getTriggers(trigger) {
                var show = trigger || options.trigger || defaultTriggerShow;
                var hide = triggerMap[show] || show;
                return {
                    show: show,
                    hide: hide
                };
            }
            var directiveName = snake_case(type);
            var startSym = $interpolate.startSymbol();
            var endSym = $interpolate.endSymbol();
            var template = "<div " + directiveName + "-popup " + 'title="' + startSym + "tt_title" + endSym + '" ' + 'content="' + startSym + "tt_content" + endSym + '" ' + 'placement="' + startSym + "tt_placement" + endSym + '" ' + 'animation="tt_animation" ' + 'is-open="tt_isOpen"' + ">" + "</div>";
            return {
                restrict: "EA",
                scope: true,
                link: function link(scope, element, attrs) {
                    var tooltip = $compile(template)(scope);
                    var transitionTimeout;
                    var popupTimeout;
                    var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                    var triggers = getTriggers(undefined);
                    var hasRegisteredTriggers = false;
                    var hasEnableExp = angular.isDefined(attrs[prefix + "Enable"]);
                    var positionTooltip = function() {
                        var position, ttWidth, ttHeight, ttPosition;
                        // Get the position of the directive element.
                        position = appendToBody ? $position.offset(element) : $position.position(element);
                        // Get the height and width of the tooltip so we can center it.
                        ttWidth = tooltip.prop("offsetWidth");
                        ttHeight = tooltip.prop("offsetHeight");
                        // Calculate the tooltip's top and left coordinates to center it with
                        // this directive.
                        switch (scope.tt_placement) {
                          case "right":
                            ttPosition = {
                                top: position.top + position.height / 2 - ttHeight / 2,
                                left: position.left + position.width
                            };
                            break;

                          case "bottom":
                            ttPosition = {
                                top: position.top + position.height,
                                left: position.left + position.width / 2 - ttWidth / 2
                            };
                            break;

                          case "left":
                            ttPosition = {
                                top: position.top + position.height / 2 - ttHeight / 2,
                                left: position.left - ttWidth
                            };
                            break;

                          default:
                            ttPosition = {
                                top: position.top - ttHeight,
                                left: position.left + position.width / 2 - ttWidth / 2
                            };
                            break;
                        }
                        ttPosition.top += "px";
                        ttPosition.left += "px";
                        // Now set the calculated positioning.
                        tooltip.css(ttPosition);
                    };
                    // By default, the tooltip is not open.
                    // TODO add ability to start tooltip opened
                    scope.tt_isOpen = false;
                    function toggleTooltipBind() {
                        if (!scope.tt_isOpen) {
                            showTooltipBind();
                        } else {
                            hideTooltipBind();
                        }
                    }
                    // Show the tooltip with delay if specified, otherwise show it immediately
                    function showTooltipBind() {
                        if (hasEnableExp && !scope.$eval(attrs[prefix + "Enable"])) {
                            return;
                        }
                        if (scope.tt_popupDelay) {
                            popupTimeout = $timeout(show, scope.tt_popupDelay);
                            popupTimeout.then(function(reposition) {
                                reposition();
                            });
                        } else {
                            scope.$apply(show)();
                        }
                    }
                    function hideTooltipBind() {
                        scope.$apply(function() {
                            hide();
                        });
                    }
                    // Show the tooltip popup element.
                    function show() {
                        // Don't show empty tooltips.
                        if (!scope.tt_content) {
                            return angular.noop;
                        }
                        // If there is a pending remove transition, we must cancel it, lest the
                        // tooltip be mysteriously removed.
                        if (transitionTimeout) {
                            $timeout.cancel(transitionTimeout);
                        }
                        // Set the initial positioning.
                        tooltip.css({
                            top: 0,
                            left: 0,
                            display: "block"
                        });
                        // Now we add it to the DOM because need some info about it. But it's not 
                        // visible yet anyway.
                        if (appendToBody) {
                            $document.find("body").append(tooltip);
                        } else {
                            element.after(tooltip);
                        }
                        positionTooltip();
                        // And show the tooltip.
                        scope.tt_isOpen = true;
                        // Return positioning function as promise callback for correct
                        // positioning after draw.
                        return positionTooltip;
                    }
                    // Hide the tooltip popup element.
                    function hide() {
                        // First things first: we don't show it anymore.
                        scope.tt_isOpen = false;
                        //if tooltip is going to be shown after delay, we must cancel this
                        $timeout.cancel(popupTimeout);
                        // And now we remove it from the DOM. However, if we have animation, we 
                        // need to wait for it to expire beforehand.
                        // FIXME: this is a placeholder for a port of the transitions library.
                        if (scope.tt_animation) {
                            transitionTimeout = $timeout(function() {
                                tooltip.remove();
                            }, 500);
                        } else {
                            tooltip.remove();
                        }
                    }
                    /**
           * Observe the relevant attributes.
           */
                    attrs.$observe(type, function(val) {
                        scope.tt_content = val;
                        if (!val && scope.tt_isOpen) {
                            hide();
                        }
                    });
                    attrs.$observe(prefix + "Title", function(val) {
                        scope.tt_title = val;
                    });
                    attrs.$observe(prefix + "Placement", function(val) {
                        scope.tt_placement = angular.isDefined(val) ? val : options.placement;
                    });
                    attrs.$observe(prefix + "PopupDelay", function(val) {
                        var delay = parseInt(val, 10);
                        scope.tt_popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                    });
                    var unregisterTriggers = function() {
                        if (hasRegisteredTriggers) {
                            element.unbind(triggers.show, showTooltipBind);
                            element.unbind(triggers.hide, hideTooltipBind);
                        }
                    };
                    attrs.$observe(prefix + "Trigger", function(val) {
                        unregisterTriggers();
                        triggers = getTriggers(val);
                        if (triggers.show === triggers.hide) {
                            element.bind(triggers.show, toggleTooltipBind);
                        } else {
                            element.bind(triggers.show, showTooltipBind);
                            element.bind(triggers.hide, hideTooltipBind);
                        }
                        hasRegisteredTriggers = true;
                    });
                    var animation = scope.$eval(attrs[prefix + "Animation"]);
                    scope.tt_animation = angular.isDefined(animation) ? !!animation : options.animation;
                    attrs.$observe(prefix + "AppendToBody", function(val) {
                        appendToBody = angular.isDefined(val) ? $parse(val)(scope) : appendToBody;
                    });
                    // if a tooltip is attached to <body> we need to remove it on
                    // location change as its parent scope will probably not be destroyed
                    // by the change.
                    if (appendToBody) {
                        scope.$on("$locationChangeSuccess", function closeTooltipOnLocationChangeSuccess() {
                            if (scope.tt_isOpen) {
                                hide();
                            }
                        });
                    }
                    // Make sure tooltip is destroyed and removed.
                    scope.$on("$destroy", function onDestroyTooltip() {
                        $timeout.cancel(transitionTimeout);
                        $timeout.cancel(popupTimeout);
                        unregisterTriggers();
                        tooltip.remove();
                        tooltip.unbind();
                        tooltip = null;
                    });
                }
            };
        };
    } ];
}).directive("tooltipPopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-popup.html"
    };
}).directive("tooltip", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltip", "tooltip", "mouseenter");
} ]).directive("tooltipHtmlUnsafePopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/tooltip/tooltip-html-unsafe-popup.html"
    };
}).directive("tooltipHtmlUnsafe", [ "$tooltip", function($tooltip) {
    return $tooltip("tooltipHtmlUnsafe", "tooltip", "mouseenter");
} ]);

/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module("ui.bootstrap.popover", [ "ui.bootstrap.tooltip" ]).directive("popoverPopup", function() {
    return {
        restrict: "EA",
        replace: true,
        scope: {
            title: "@",
            content: "@",
            placement: "@",
            animation: "&",
            isOpen: "&"
        },
        templateUrl: "template/popover/popover.html"
    };
}).directive("popover", [ "$compile", "$timeout", "$parse", "$window", "$tooltip", function($compile, $timeout, $parse, $window, $tooltip) {
    return $tooltip("popover", "popover", "click");
} ]);

angular.module("ui.bootstrap.progressbar", [ "ui.bootstrap.transition" ]).constant("progressConfig", {
    animate: true,
    max: 100
}).controller("ProgressController", [ "$scope", "$attrs", "progressConfig", "$transition", function($scope, $attrs, progressConfig, $transition) {
    var self = this, bars = [], max = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : progressConfig.max, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
    this.addBar = function(bar, element) {
        var oldValue = 0, index = bar.$parent.$index;
        if (angular.isDefined(index) && bars[index]) {
            oldValue = bars[index].value;
        }
        bars.push(bar);
        this.update(element, bar.value, oldValue);
        bar.$watch("value", function(value, oldValue) {
            if (value !== oldValue) {
                self.update(element, value, oldValue);
            }
        });
        bar.$on("$destroy", function() {
            self.removeBar(bar);
        });
    };
    // Update bar element width
    this.update = function(element, newValue, oldValue) {
        var percent = this.getPercentage(newValue);
        if (animate) {
            element.css("width", this.getPercentage(oldValue) + "%");
            $transition(element, {
                width: percent + "%"
            });
        } else {
            element.css({
                transition: "none",
                width: percent + "%"
            });
        }
    };
    this.removeBar = function(bar) {
        bars.splice(bars.indexOf(bar), 1);
    };
    this.getPercentage = function(value) {
        return Math.round(100 * value / max);
    };
} ]).directive("progress", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        controller: "ProgressController",
        require: "progress",
        scope: {},
        template: '<div class="progress" ng-transclude></div>'
    };
}).directive("bar", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        require: "^progress",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/bar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, element);
        }
    };
}).directive("progressbar", function() {
    return {
        restrict: "EA",
        replace: true,
        transclude: true,
        controller: "ProgressController",
        scope: {
            value: "=",
            type: "@"
        },
        templateUrl: "template/progressbar/progressbar.html",
        link: function(scope, element, attrs, progressCtrl) {
            progressCtrl.addBar(scope, angular.element(element.children()[0]));
        }
    };
});

angular.module("ui.bootstrap.rating", []).constant("ratingConfig", {
    max: 5,
    stateOn: null,
    stateOff: null
}).controller("RatingController", [ "$scope", "$attrs", "$parse", "ratingConfig", function($scope, $attrs, $parse, ratingConfig) {
    this.maxRange = angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max;
    this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
    this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
    this.createRateObjects = function(states) {
        var defaultOptions = {
            stateOn: this.stateOn,
            stateOff: this.stateOff
        };
        for (var i = 0, n = states.length; i < n; i++) {
            states[i] = angular.extend({
                index: i
            }, defaultOptions, states[i]);
        }
        return states;
    };
    // Get objects used in template
    $scope.range = angular.isDefined($attrs.ratingStates) ? this.createRateObjects(angular.copy($scope.$parent.$eval($attrs.ratingStates))) : this.createRateObjects(new Array(this.maxRange));
    $scope.rate = function(value) {
        if ($scope.readonly || $scope.value === value) {
            return;
        }
        $scope.value = value;
    };
    $scope.enter = function(value) {
        if (!$scope.readonly) {
            $scope.val = value;
        }
        $scope.onHover({
            value: value
        });
    };
    $scope.reset = function() {
        $scope.val = angular.copy($scope.value);
        $scope.onLeave();
    };
    $scope.$watch("value", function(value) {
        $scope.val = value;
    });
    $scope.readonly = false;
    if ($attrs.readonly) {
        $scope.$parent.$watch($parse($attrs.readonly), function(value) {
            $scope.readonly = !!value;
        });
    }
} ]).directive("rating", function() {
    return {
        restrict: "EA",
        scope: {
            value: "=",
            onHover: "&",
            onLeave: "&"
        },
        controller: "RatingController",
        templateUrl: "template/rating/rating.html",
        replace: true
    };
});

/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */
angular.module("ui.bootstrap.tabs", []).controller("TabsetController", [ "$scope", function TabsetCtrl($scope) {
    var ctrl = this, tabs = ctrl.tabs = $scope.tabs = [];
    ctrl.select = function(tab) {
        angular.forEach(tabs, function(tab) {
            tab.active = false;
        });
        tab.active = true;
    };
    ctrl.addTab = function addTab(tab) {
        tabs.push(tab);
        if (tabs.length === 1 || tab.active) {
            ctrl.select(tab);
        }
    };
    ctrl.removeTab = function removeTab(tab) {
        var index = tabs.indexOf(tab);
        //Select a new tab if the tab to be removed is selected
        if (tab.active && tabs.length > 1) {
            //If this is the last tab, select the previous tab. else, the next tab.
            var newActiveIndex = index == tabs.length - 1 ? index - 1 : index + 1;
            ctrl.select(tabs[newActiveIndex]);
        }
        tabs.splice(index, 1);
    };
} ]).directive("tabset", function() {
    return {
        restrict: "EA",
        transclude: true,
        replace: true,
        scope: {},
        controller: "TabsetController",
        templateUrl: "template/tabs/tabset.html",
        link: function(scope, element, attrs) {
            scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
            scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
            scope.type = angular.isDefined(attrs.type) ? scope.$parent.$eval(attrs.type) : "tabs";
        }
    };
}).directive("tab", [ "$parse", function($parse) {
    return {
        require: "^tabset",
        restrict: "EA",
        replace: true,
        templateUrl: "template/tabs/tab.html",
        transclude: true,
        scope: {
            heading: "@",
            onSelect: "&select",
            //This callback is called in contentHeadingTransclude
            //once it inserts the tab's content into the dom
            onDeselect: "&deselect"
        },
        controller: function() {},
        compile: function(elm, attrs, transclude) {
            return function postLink(scope, elm, attrs, tabsetCtrl) {
                var getActive, setActive;
                if (attrs.active) {
                    getActive = $parse(attrs.active);
                    setActive = getActive.assign;
                    scope.$parent.$watch(getActive, function updateActive(value, oldVal) {
                        // Avoid re-initializing scope.active as it is already initialized
                        // below. (watcher is called async during init with value ===
                        // oldVal)
                        if (value !== oldVal) {
                            scope.active = !!value;
                        }
                    });
                    scope.active = getActive(scope.$parent);
                } else {
                    setActive = getActive = angular.noop;
                }
                scope.$watch("active", function(active) {
                    // Note this watcher also initializes and assigns scope.active to the
                    // attrs.active expression.
                    setActive(scope.$parent, active);
                    if (active) {
                        tabsetCtrl.select(scope);
                        scope.onSelect();
                    } else {
                        scope.onDeselect();
                    }
                });
                scope.disabled = false;
                if (attrs.disabled) {
                    scope.$parent.$watch($parse(attrs.disabled), function(value) {
                        scope.disabled = !!value;
                    });
                }
                scope.select = function() {
                    if (!scope.disabled) {
                        scope.active = true;
                    }
                };
                tabsetCtrl.addTab(scope);
                scope.$on("$destroy", function() {
                    tabsetCtrl.removeTab(scope);
                });
                //We need to transclude later, once the content container is ready.
                //when this link happens, we're inside a tab heading.
                scope.$transcludeFn = transclude;
            };
        }
    };
} ]).directive("tabHeadingTransclude", [ function() {
    return {
        restrict: "A",
        require: "^tab",
        link: function(scope, elm, attrs, tabCtrl) {
            scope.$watch("headingElement", function updateHeadingElement(heading) {
                if (heading) {
                    elm.html("");
                    elm.append(heading);
                }
            });
        }
    };
} ]).directive("tabContentTransclude", function() {
    return {
        restrict: "A",
        require: "^tabset",
        link: function(scope, elm, attrs) {
            var tab = scope.$eval(attrs.tabContentTransclude);
            //Now our tab is ready to be transcluded: both the tab heading area
            //and the tab content area are loaded.  Transclude 'em both.
            tab.$transcludeFn(tab.$parent, function(contents) {
                angular.forEach(contents, function(node) {
                    if (isTabHeading(node)) {
                        //Let tabHeadingTransclude know.
                        tab.headingElement = node;
                    } else {
                        elm.append(node);
                    }
                });
            });
        }
    };
    function isTabHeading(node) {
        return node.tagName && (node.hasAttribute("tab-heading") || node.hasAttribute("data-tab-heading") || node.tagName.toLowerCase() === "tab-heading" || node.tagName.toLowerCase() === "data-tab-heading");
    }
});

angular.module("ui.bootstrap.timepicker", []).constant("timepickerConfig", {
    hourStep: 1,
    minuteStep: 1,
    showMeridian: true,
    meridians: null,
    readonlyInput: false,
    mousewheel: true
}).directive("timepicker", [ "$parse", "$log", "timepickerConfig", "$locale", function($parse, $log, timepickerConfig, $locale) {
    return {
        restrict: "EA",
        require: "?^ngModel",
        replace: true,
        scope: {},
        templateUrl: "template/timepicker/timepicker.html",
        link: function(scope, element, attrs, ngModel) {
            if (!ngModel) {
                return;
            }
            var selected = new Date(), meridians = angular.isDefined(attrs.meridians) ? scope.$parent.$eval(attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS;
            var hourStep = timepickerConfig.hourStep;
            if (attrs.hourStep) {
                scope.$parent.$watch($parse(attrs.hourStep), function(value) {
                    hourStep = parseInt(value, 10);
                });
            }
            var minuteStep = timepickerConfig.minuteStep;
            if (attrs.minuteStep) {
                scope.$parent.$watch($parse(attrs.minuteStep), function(value) {
                    minuteStep = parseInt(value, 10);
                });
            }
            // 12H / 24H mode
            scope.showMeridian = timepickerConfig.showMeridian;
            if (attrs.showMeridian) {
                scope.$parent.$watch($parse(attrs.showMeridian), function(value) {
                    scope.showMeridian = !!value;
                    if (ngModel.$error.time) {
                        // Evaluate from template
                        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                            selected.setHours(hours);
                            refresh();
                        }
                    } else {
                        updateTemplate();
                    }
                });
            }
            // Get scope.hours in 24H mode if valid
            function getHoursFromTemplate() {
                var hours = parseInt(scope.hours, 10);
                var valid = scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
                if (!valid) {
                    return undefined;
                }
                if (scope.showMeridian) {
                    if (hours === 12) {
                        hours = 0;
                    }
                    if (scope.meridian === meridians[1]) {
                        hours = hours + 12;
                    }
                }
                return hours;
            }
            function getMinutesFromTemplate() {
                var minutes = parseInt(scope.minutes, 10);
                return minutes >= 0 && minutes < 60 ? minutes : undefined;
            }
            function pad(value) {
                return angular.isDefined(value) && value.toString().length < 2 ? "0" + value : value;
            }
            // Input elements
            var inputs = element.find("input"), hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1);
            // Respond on mousewheel spin
            var mousewheel = angular.isDefined(attrs.mousewheel) ? scope.$eval(attrs.mousewheel) : timepickerConfig.mousewheel;
            if (mousewheel) {
                var isScrollingUp = function(e) {
                    if (e.originalEvent) {
                        e = e.originalEvent;
                    }
                    //pick correct delta variable depending on event
                    var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
                    return e.detail || delta > 0;
                };
                hoursInputEl.bind("mousewheel wheel", function(e) {
                    scope.$apply(isScrollingUp(e) ? scope.incrementHours() : scope.decrementHours());
                    e.preventDefault();
                });
                minutesInputEl.bind("mousewheel wheel", function(e) {
                    scope.$apply(isScrollingUp(e) ? scope.incrementMinutes() : scope.decrementMinutes());
                    e.preventDefault();
                });
            }
            scope.readonlyInput = angular.isDefined(attrs.readonlyInput) ? scope.$eval(attrs.readonlyInput) : timepickerConfig.readonlyInput;
            if (!scope.readonlyInput) {
                var invalidate = function(invalidHours, invalidMinutes) {
                    ngModel.$setViewValue(null);
                    ngModel.$setValidity("time", false);
                    if (angular.isDefined(invalidHours)) {
                        scope.invalidHours = invalidHours;
                    }
                    if (angular.isDefined(invalidMinutes)) {
                        scope.invalidMinutes = invalidMinutes;
                    }
                };
                scope.updateHours = function() {
                    var hours = getHoursFromTemplate();
                    if (angular.isDefined(hours)) {
                        selected.setHours(hours);
                        refresh("h");
                    } else {
                        invalidate(true);
                    }
                };
                hoursInputEl.bind("blur", function(e) {
                    if (!scope.validHours && scope.hours < 10) {
                        scope.$apply(function() {
                            scope.hours = pad(scope.hours);
                        });
                    }
                });
                scope.updateMinutes = function() {
                    var minutes = getMinutesFromTemplate();
                    if (angular.isDefined(minutes)) {
                        selected.setMinutes(minutes);
                        refresh("m");
                    } else {
                        invalidate(undefined, true);
                    }
                };
                minutesInputEl.bind("blur", function(e) {
                    if (!scope.invalidMinutes && scope.minutes < 10) {
                        scope.$apply(function() {
                            scope.minutes = pad(scope.minutes);
                        });
                    }
                });
            } else {
                scope.updateHours = angular.noop;
                scope.updateMinutes = angular.noop;
            }
            ngModel.$render = function() {
                var date = ngModel.$modelValue ? new Date(ngModel.$modelValue) : null;
                if (isNaN(date)) {
                    ngModel.$setValidity("time", false);
                    $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
                } else {
                    if (date) {
                        selected = date;
                    }
                    makeValid();
                    updateTemplate();
                }
            };
            // Call internally when we know that model is valid.
            function refresh(keyboardChange) {
                makeValid();
                ngModel.$setViewValue(new Date(selected));
                updateTemplate(keyboardChange);
            }
            function makeValid() {
                ngModel.$setValidity("time", true);
                scope.invalidHours = false;
                scope.invalidMinutes = false;
            }
            function updateTemplate(keyboardChange) {
                var hours = selected.getHours(), minutes = selected.getMinutes();
                if (scope.showMeridian) {
                    hours = hours === 0 || hours === 12 ? 12 : hours % 12;
                }
                scope.hours = keyboardChange === "h" ? hours : pad(hours);
                scope.minutes = keyboardChange === "m" ? minutes : pad(minutes);
                scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
            }
            function addMinutes(minutes) {
                var dt = new Date(selected.getTime() + minutes * 6e4);
                selected.setHours(dt.getHours(), dt.getMinutes());
                refresh();
            }
            scope.incrementHours = function() {
                addMinutes(hourStep * 60);
            };
            scope.decrementHours = function() {
                addMinutes(-hourStep * 60);
            };
            scope.incrementMinutes = function() {
                addMinutes(minuteStep);
            };
            scope.decrementMinutes = function() {
                addMinutes(-minuteStep);
            };
            scope.toggleMeridian = function() {
                addMinutes(12 * 60 * (selected.getHours() < 12 ? 1 : -1));
            };
        }
    };
} ]);

angular.module("ui.bootstrap.typeahead", [ "ui.bootstrap.position", "ui.bootstrap.bindHtml" ]).factory("typeaheadParser", [ "$parse", function($parse) {
    //                      00000111000000000000022200000000000000003333333333333330000000000044000
    var TYPEAHEAD_REGEXP = /^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;
    return {
        parse: function(input) {
            var match = input.match(TYPEAHEAD_REGEXP), modelMapper, viewMapper, source;
            if (!match) {
                throw new Error("Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_'" + " but got '" + input + "'.");
            }
            return {
                itemName: match[3],
                source: $parse(match[4]),
                viewMapper: $parse(match[2] || match[1]),
                modelMapper: $parse(match[1])
            };
        }
    };
} ]).directive("typeahead", [ "$compile", "$parse", "$q", "$timeout", "$document", "$position", "typeaheadParser", function($compile, $parse, $q, $timeout, $document, $position, typeaheadParser) {
    var HOT_KEYS = [ 9, 13, 27, 38, 40 ];
    return {
        require: "ngModel",
        link: function(originalScope, element, attrs, modelCtrl) {
            //SUPPORTED ATTRIBUTES (OPTIONS)
            //minimal no of characters that needs to be entered before typeahead kicks-in
            var minSearch = originalScope.$eval(attrs.typeaheadMinLength) || 1;
            //minimal wait time after last character typed before typehead kicks-in
            var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
            //should it restrict model values to the ones selected from the popup only?
            var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
            //binding to a variable that indicates if matches are being retrieved asynchronously
            var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
            //a callback executed when a match is selected
            var onSelectCallback = $parse(attrs.typeaheadOnSelect);
            var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
            var appendToBody = attrs.typeaheadAppendToBody ? $parse(attrs.typeaheadAppendToBody) : false;
            //INTERNAL VARIABLES
            //model setter executed upon match selection
            var $setModelValue = $parse(attrs.ngModel).assign;
            //expressions used by typeahead
            var parserResult = typeaheadParser.parse(attrs.typeahead);
            var hasFocus;
            //pop-up element used to display matches
            var popUpEl = angular.element("<div typeahead-popup></div>");
            popUpEl.attr({
                matches: "matches",
                active: "activeIdx",
                select: "select(activeIdx)",
                query: "query",
                position: "position"
            });
            //custom item template
            if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
                popUpEl.attr("template-url", attrs.typeaheadTemplateUrl);
            }
            //create a child scope for the typeahead directive so we are not polluting original scope
            //with typeahead-specific data (matches, query etc.)
            var scope = originalScope.$new();
            originalScope.$on("$destroy", function() {
                scope.$destroy();
            });
            var resetMatches = function() {
                scope.matches = [];
                scope.activeIdx = -1;
            };
            var getMatchesAsync = function(inputValue) {
                var locals = {
                    $viewValue: inputValue
                };
                isLoadingSetter(originalScope, true);
                $q.when(parserResult.source(originalScope, locals)).then(function(matches) {
                    //it might happen that several async queries were in progress if a user were typing fast
                    //but we are interested only in responses that correspond to the current view value
                    if (inputValue === modelCtrl.$viewValue && hasFocus) {
                        if (matches.length > 0) {
                            scope.activeIdx = 0;
                            scope.matches.length = 0;
                            //transform labels
                            for (var i = 0; i < matches.length; i++) {
                                locals[parserResult.itemName] = matches[i];
                                scope.matches.push({
                                    label: parserResult.viewMapper(scope, locals),
                                    model: matches[i]
                                });
                            }
                            scope.query = inputValue;
                            //position pop-up with matches - we need to re-calculate its position each time we are opening a window
                            //with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
                            //due to other elements being rendered
                            scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                            scope.position.top = scope.position.top + element.prop("offsetHeight");
                        } else {
                            resetMatches();
                        }
                        isLoadingSetter(originalScope, false);
                    }
                }, function() {
                    resetMatches();
                    isLoadingSetter(originalScope, false);
                });
            };
            resetMatches();
            //we need to propagate user's query so we can higlight matches
            scope.query = undefined;
            //Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
            var timeoutPromise;
            //plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
            //$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
            modelCtrl.$parsers.unshift(function(inputValue) {
                hasFocus = true;
                if (inputValue && inputValue.length >= minSearch) {
                    if (waitTime > 0) {
                        if (timeoutPromise) {
                            $timeout.cancel(timeoutPromise);
                        }
                        timeoutPromise = $timeout(function() {
                            getMatchesAsync(inputValue);
                        }, waitTime);
                    } else {
                        getMatchesAsync(inputValue);
                    }
                } else {
                    isLoadingSetter(originalScope, false);
                    resetMatches();
                }
                if (isEditable) {
                    return inputValue;
                } else {
                    if (!inputValue) {
                        // Reset in case user had typed something previously.
                        modelCtrl.$setValidity("editable", true);
                        return inputValue;
                    } else {
                        modelCtrl.$setValidity("editable", false);
                        return undefined;
                    }
                }
            });
            modelCtrl.$formatters.push(function(modelValue) {
                var candidateViewValue, emptyViewValue;
                var locals = {};
                if (inputFormatter) {
                    locals["$model"] = modelValue;
                    return inputFormatter(originalScope, locals);
                } else {
                    //it might happen that we don't have enough info to properly render input value
                    //we need to check for this situation and simply return model value if we can't apply custom formatting
                    locals[parserResult.itemName] = modelValue;
                    candidateViewValue = parserResult.viewMapper(originalScope, locals);
                    locals[parserResult.itemName] = undefined;
                    emptyViewValue = parserResult.viewMapper(originalScope, locals);
                    return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
                }
            });
            scope.select = function(activeIdx) {
                //called from within the $digest() cycle
                var locals = {};
                var model, item;
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
                model = parserResult.modelMapper(originalScope, locals);
                $setModelValue(originalScope, model);
                modelCtrl.$setValidity("editable", true);
                onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals)
                });
                resetMatches();
                //return focus to the input element if a mach was selected via a mouse click event
                element[0].focus();
            };
            //bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
            element.bind("keydown", function(evt) {
                //typeahead is open and an "interesting" key was pressed
                if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                    return;
                }
                evt.preventDefault();
                if (evt.which === 40) {
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                    scope.$digest();
                } else if (evt.which === 38) {
                    scope.activeIdx = (scope.activeIdx ? scope.activeIdx : scope.matches.length) - 1;
                    scope.$digest();
                } else if (evt.which === 13 || evt.which === 9) {
                    scope.$apply(function() {
                        scope.select(scope.activeIdx);
                    });
                } else if (evt.which === 27) {
                    evt.stopPropagation();
                    resetMatches();
                    scope.$digest();
                }
            });
            element.bind("blur", function(evt) {
                hasFocus = false;
            });
            // Keep reference to click handler to unbind it.
            var dismissClickHandler = function(evt) {
                if (element[0] !== evt.target) {
                    resetMatches();
                    scope.$digest();
                }
            };
            $document.bind("click", dismissClickHandler);
            originalScope.$on("$destroy", function() {
                $document.unbind("click", dismissClickHandler);
            });
            var $popup = $compile(popUpEl)(scope);
            if (appendToBody) {
                $document.find("body").append($popup);
            } else {
                element.after($popup);
            }
        }
    };
} ]).directive("typeaheadPopup", function() {
    return {
        restrict: "EA",
        scope: {
            matches: "=",
            query: "=",
            active: "=",
            position: "=",
            select: "&"
        },
        replace: true,
        templateUrl: "template/typeahead/typeahead-popup.html",
        link: function(scope, element, attrs) {
            scope.templateUrl = attrs.templateUrl;
            scope.isOpen = function() {
                return scope.matches.length > 0;
            };
            scope.isActive = function(matchIdx) {
                return scope.active == matchIdx;
            };
            scope.selectActive = function(matchIdx) {
                scope.active = matchIdx;
            };
            scope.selectMatch = function(activeIdx) {
                scope.select({
                    activeIdx: activeIdx
                });
            };
        }
    };
}).directive("typeaheadMatch", [ "$http", "$templateCache", "$compile", "$parse", function($http, $templateCache, $compile, $parse) {
    return {
        restrict: "EA",
        scope: {
            index: "=",
            match: "=",
            query: "="
        },
        link: function(scope, element, attrs) {
            var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || "template/typeahead/typeahead-match.html";
            $http.get(tplUrl, {
                cache: $templateCache
            }).success(function(tplContent) {
                element.replaceWith($compile(tplContent.trim())(scope));
            });
        }
    };
} ]).filter("typeaheadHighlight", function() {
    function escapeRegexp(queryToEscape) {
        return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
    }
    return function(matchItem, query) {
        return query ? matchItem.replace(new RegExp(escapeRegexp(query), "gi"), "<strong>$&</strong>") : matchItem;
    };
});

angular.module("template/accordion/accordion-group.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion-group.html", '<div class="panel panel-default">\n' + '  <div class="panel-heading">\n' + '    <h4 class="panel-title">\n' + '      <a class="accordion-toggle" ng-click="isOpen = !isOpen" accordion-transclude="heading">{{heading}}</a>\n' + "    </h4>\n" + "  </div>\n" + '  <div class="panel-collapse" collapse="!isOpen">\n' + '	  <div class="panel-body" ng-transclude></div>\n' + "  </div>\n" + "</div>");
} ]);

angular.module("template/accordion/accordion.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/accordion/accordion.html", '<div class="panel-group" ng-transclude></div>');
} ]);

angular.module("template/alert/alert.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/alert/alert.html", "<div class='alert' ng-class='\"alert-\" + (type || \"warning\")'>\n" + "    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n" + "    <div ng-transclude></div>\n" + "</div>\n" + "");
} ]);

angular.module("template/carousel/carousel.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/carousel.html", '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel">\n' + '    <ol class="carousel-indicators" ng-show="slides().length > 1">\n' + '        <li ng-repeat="slide in slides()" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n' + "    </ol>\n" + '    <div class="carousel-inner" ng-transclude></div>\n' + '    <a class="left carousel-control" ng-click="prev()" ng-show="slides().length > 1"><span class="icon-prev"></span></a>\n' + '    <a class="right carousel-control" ng-click="next()" ng-show="slides().length > 1"><span class="icon-next"></span></a>\n' + "</div>\n" + "");
} ]);

angular.module("template/carousel/slide.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/carousel/slide.html", '<div ng-class="{\n' + "    'active': leaving || (active && !entering),\n" + "    'prev': (next || active) && direction=='prev',\n" + "    'next': (next || active) && direction=='next',\n" + "    'right': direction=='prev',\n" + "    'left': direction=='next'\n" + '  }" class="item text-center" ng-transclude></div>\n' + "");
} ]);

angular.module("template/datepicker/datepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/datepicker.html", "<table>\n" + "  <thead>\n" + "    <tr>\n" + '      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="{{rows[0].length - 2 + showWeekNumbers}}"><button type="button" class="btn btn-default btn-sm btn-block" ng-click="toggleMode()"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + "    </tr>\n" + '    <tr ng-show="labels.length > 0" class="h6">\n' + '      <th ng-show="showWeekNumbers" class="text-center">#</th>\n' + '      <th ng-repeat="label in labels" class="text-center">{{label}}</th>\n' + "    </tr>\n" + "  </thead>\n" + "  <tbody>\n" + '    <tr ng-repeat="row in rows">\n' + '      <td ng-show="showWeekNumbers" class="text-center"><em>{{ getWeekNumber(row) }}</em></td>\n' + '      <td ng-repeat="dt in row" class="text-center">\n' + '        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected}" ng-click="select(dt.date)" ng-disabled="dt.disabled"><span ng-class="{\'text-muted\': dt.secondary}">{{dt.label}}</span></button>\n' + "      </td>\n" + "    </tr>\n" + "  </tbody>\n" + "</table>\n" + "");
} ]);

angular.module("template/datepicker/popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/datepicker/popup.html", "<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\">\n" + "	<li ng-transclude></li>\n" + '	<li ng-show="showButtonBar" style="padding:10px 9px 2px">\n' + '		<span class="btn-group">\n' + '			<button type="button" class="btn btn-sm btn-info" ng-click="today()">{{currentText}}</button>\n' + '			<button type="button" class="btn btn-sm btn-default" ng-click="showWeeks = ! showWeeks" ng-class="{active: showWeeks}">{{toggleWeeksText}}</button>\n' + '			<button type="button" class="btn btn-sm btn-danger" ng-click="clear()">{{clearText}}</button>\n' + "		</span>\n" + '		<button type="button" class="btn btn-sm btn-success pull-right" ng-click="isOpen = false">{{closeText}}</button>\n' + "	</li>\n" + "</ul>\n" + "");
} ]);

angular.module("template/modal/backdrop.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/backdrop.html", '<div class="modal-backdrop fade" ng-class="{in: animate}" ng-style="{\'z-index\': 1040 + index*10}"></div>');
} ]);

angular.module("template/modal/window.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/modal/window.html", '<div tabindex="-1" class="modal fade {{ windowClass }}" ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n' + '    <div class="modal-dialog"><div class="modal-content" ng-transclude></div></div>\n' + "</div>");
} ]);

angular.module("template/pagination/pager.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pager.html", '<ul class="pager">\n' + '  <li ng-repeat="page in pages" ng-class="{disabled: page.disabled, previous: page.previous, next: page.next}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n' + "</ul>");
} ]);

angular.module("template/pagination/pagination.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/pagination/pagination.html", '<ul class="pagination">\n' + '  <li ng-repeat="page in pages" ng-class="{active: page.active, disabled: page.disabled}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n' + "</ul>");
} ]);

angular.module("template/tooltip/tooltip-html-unsafe-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-html-unsafe-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/tooltip/tooltip-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tooltip/tooltip-popup.html", '<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" ng-bind="content"></div>\n' + "</div>\n" + "");
} ]);

angular.module("template/popover/popover.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/popover/popover.html", '<div class="popover {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n' + '  <div class="arrow"></div>\n' + "\n" + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n' + '      <div class="popover-content" ng-bind="content"></div>\n' + "  </div>\n" + "</div>\n" + "");
} ]);

angular.module("template/progressbar/bar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/bar.html", '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div>');
} ]);

angular.module("template/progressbar/progress.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progress.html", '<div class="progress" ng-transclude></div>');
} ]);

angular.module("template/progressbar/progressbar.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/progressbar/progressbar.html", '<div class="progress"><div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div></div>');
} ]);

angular.module("template/rating/rating.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/rating/rating.html", '<span ng-mouseleave="reset()">\n' + '    <i ng-repeat="r in range" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < val && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')"></i>\n' + "</span>");
} ]);

angular.module("template/tabs/tab.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tab.html", '<li ng-class="{active: active, disabled: disabled}">\n' + '  <a ng-click="select()" tab-heading-transclude>{{heading}}</a>\n' + "</li>\n" + "");
} ]);

angular.module("template/tabs/tabset-titles.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset-titles.html", "<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n" + "</ul>\n" + "");
} ]);

angular.module("template/tabs/tabset.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/tabs/tabset.html", "\n" + '<div class="tabbable">\n' + "  <ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical, 'nav-justified': justified}\" ng-transclude></ul>\n" + '  <div class="tab-content">\n' + '    <div class="tab-pane" \n' + '         ng-repeat="tab in tabs" \n' + '         ng-class="{active: tab.active}"\n' + '         tab-content-transclude="tab">\n' + "    </div>\n" + "  </div>\n" + "</div>\n" + "");
} ]);

angular.module("template/timepicker/timepicker.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/timepicker/timepicker.html", "<table>\n" + "	<tbody>\n" + '		<tr class="text-center">\n' + '			<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + "			<td>&nbsp;</td>\n" + '			<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '			<td ng-show="showMeridian"></td>\n' + "		</tr>\n" + "		<tr>\n" + '			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidHours}">\n' + '				<input type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-mousewheel="incrementHours()" ng-readonly="readonlyInput" maxlength="2">\n' + "			</td>\n" + "			<td>:</td>\n" + '			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n' + '				<input type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n' + "			</td>\n" + '			<td ng-show="showMeridian"><button class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n' + "		</tr>\n" + '		<tr class="text-center">\n' + '			<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + "			<td>&nbsp;</td>\n" + '			<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '			<td ng-show="showMeridian"></td>\n' + "		</tr>\n" + "	</tbody>\n" + "</table>\n" + "");
} ]);

angular.module("template/typeahead/typeahead-match.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-match.html", '<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>');
} ]);

angular.module("template/typeahead/typeahead-popup.html", []).run([ "$templateCache", function($templateCache) {
    $templateCache.put("template/typeahead/typeahead-popup.html", "<ul class=\"dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n" + '    <li ng-repeat="match in matches" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)">\n' + '        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n' + "    </li>\n" + "</ul>");
} ]);
//# sourceMappingURL=web-app/assets/sources.min.js.map