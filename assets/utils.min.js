/*! iconsult 01-02-2014 version: 1.0.0 
 author: https://twitter.com/MakBkar */

/*global angular:true, browser:true */
/**
* @license HTTP Auth Interceptor Module for AngularJS
* (c) 2012 Witold Szczerba
* License: MIT
*/
!function(){"use strict";angular.module("http-auth-interceptor",["http-auth-interceptor-buffer"]).factory("authService",["$rootScope","httpBuffer",function(a,b){return{/**
* Call this function to indicate that authentication was successfull and trigger a
* retry of all deferred requests.
* @param data an optional argument to pass on to $broadcast which may be useful for
* example if you need to pass through details of the user that was logged in
*/
loginConfirmed:function(c,d){var e=d||function(a){return a};a.$broadcast("event:auth-loginConfirmed",c),b.retryAll(e)},/**
* Call this function to indicate that authentication should not proceed.
* All deferred requests will be abandoned or rejected (if reason is provided).
* @param data an optional argument to pass on to $broadcast.
* @param reason if provided, the requests are rejected; abandoned otherwise.
*/
loginCancelled:function(c,d){b.rejectAll(d),a.$broadcast("event:auth-loginCancelled",c)}}}]).config(["$httpProvider",function(a){var b=["$rootScope","$q","httpBuffer",function(a,b,c){function d(a){return a}function e(d){if(401===d.status&&!d.config.ignoreAuthModule){var e=b.defer();return c.append(d.config,e),a.$broadcast("event:auth-loginRequired",d),e.promise}// otherwise, default behaviour
return 403==d.status?(console.log("User is not authorized for the request"),alert("UnAuthorized Action - User does not have Sufficient priviledges to complete the action ")):504==exception.code&&console.log("504 response received, change the state here to show add new records page or something"),b.reject(d)}return function(a){return a.then(d,e)}}];a.responseInterceptors.push(b)}]),/**
* Private module, a utility, required internally by 'http-auth-interceptor'.
*/
angular.module("http-auth-interceptor-buffer",[]).factory("httpBuffer",["$injector",function(a){/** Holds all the requests, so they can be re-requested in future. */
var b=[];return{/**
* Appends HTTP request configuration object with deferred response attached to buffer.
*/
append:function(a,c){b.push({config:a,deferred:c})},/**
* Abandon or reject (if reason provided) all the buffered requests.
*/
rejectAll:function(a){if(a)for(var c in b)b[c].deferred.reject(a);b=[]},/**
* Retries all the buffered requests clears the buffer.
*/
retryAll:function(){//TBD : commented this code as it was not having the token, it has to be changed
// so that $state has be to used to retry requests
//for (var i in buffer) {
//retryHttpRequest(updater(buffer[i].config), buffer[i].deferred);
//}
b=[]}}}])}(),angular.module("fundoo.services",[]).factory("createDialog",["$document","$compile","$rootScope","$controller","$timeout",function(a,b,c,d,e){var f={id:null,template:null,templateUrl:null,title:"Default Title",backdrop:!0,success:{label:"OK",fn:null},cancel:{label:"Close",fn:null},controller:null,//just like route controller declaration
backdropClass:"modal-backdrop",footerTemplate:null,modalClass:"modal",css:{}},g=a.find("body");return function(a,h,i){// Handle arguments if optional template isn't provided.
angular.isObject(a)?(i=h,h=a):h.templateUrl=a,h=angular.extend({},f,h);//options defined in constructor
var j,k=h.id?' id="'+h.id+'" ':"",l='<button class="btn" ng-click="$modalCancel()">{{$modalCancelLabel}}</button><button type="submit" class="btn btn-primary">{{$modalSuccessLabel}}</button>',m='<div class="modal-footer">'+(h.footerTemplate||l)+"</div>",n=function(){return h.template?angular.isString(h.template)?'<div class="modal-body">'+h.template+"</div>":'<div class="modal-body">'+h.template.html()+"</div>":'<div class="modal-body" ng-include="\''+h.templateUrl+"'\"></div>"}(),o=angular.element('<div class="'+h.modalClass+' fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true"'+k+'>  <div class="modal-dialog">    <div class="modal-content">      <div class="modal-header">        <button type="button" class="close" data-dismiss="modal" aria-hidden="true" ng-click="$modalCancel()">&times;</button>        <h4 class="modal-title">{{$title}}</h4>      </div>      <form ng-submit="submit($modalSuccess)" editable-form>'+n+m+"      </form>    </div>  </div></div>");for(j in h.css)o.css(j,h.css[j]);var p=angular.element('<div ng-click="$modalCancel()">');p.addClass(h.backdropClass),p.addClass("fade in");var q=function(a){27===a.keyCode&&u.$modalCancel()},r=function(){g.unbind("keydown",q),o.remove(),h.backdrop&&p.remove()};g.bind("keydown",q);var s,t,u=h.scope||c.$new();u.$title=h.title,u.$modalClose=r,u.$modalCancel=function(){var a=h.cancel.fn||r;a.call(this),u.$modalClose()},u.$modalSuccess=function(){var a=h.success.fn||r;arguments?a.call(this,arguments[0]):a.call(this),u.$modalClose()},u.$modalSuccessLabel=h.success.label,u.$modalCancelLabel=h.cancel.label,h.controller&&(t=angular.extend({$scope:u},i),s=d(h.controller,t),// Yes, ngControllerController is not a typo
o.contents().data("$ngControllerController",s)),b(o)(u),b(p)(u),g.append(o),h.backdrop&&g.append(p),e(function(){o.addClass("in")},200)}}]),function(a){a(["jquery"],function(a){return function(){//#region Accessible Methods
function b(a,b,c){return j({type:r.error,iconClass:l().iconClasses.error,message:a,optionsOverride:c,title:b})}function c(a,b,c){return j({type:r.info,iconClass:l().iconClasses.info,message:a,optionsOverride:c,title:b})}function d(a){o=a}function e(a,b,c){return j({type:r.success,iconClass:l().iconClasses.success,message:a,optionsOverride:c,title:b})}function f(a,b,c){return j({type:r.warning,iconClass:l().iconClasses.warning,message:a,optionsOverride:c,title:b})}function g(b){var c=l();return n||k(c),b&&0===a(":focus",b).length?void b[c.hideMethod]({duration:c.hideDuration,easing:c.hideEasing,complete:function(){m(b)}}):void(n.children().length&&n[c.hideMethod]({duration:c.hideDuration,easing:c.hideEasing,complete:function(){n.remove()}}))}//#endregion
//#region Internal Methods
function h(){return{tapToDismiss:!0,toastClass:"toast",containerId:"toast-container",debug:!1,showMethod:"fadeIn",//fadeIn, slideDown, and show are built into jQuery
showDuration:300,showEasing:"swing",//swing and linear are built into jQuery
onShown:void 0,hideMethod:"fadeOut",hideDuration:1e3,hideEasing:"swing",onHidden:void 0,extendedTimeOut:1e3,iconClasses:{error:"toast-error",info:"toast-info",success:"toast-success",warning:"toast-warning"},iconClass:"toast-info",positionClass:"toast-top-center",timeOut:5e3,// Set timeOut and extendedTimeout to 0 to make it sticky
titleClass:"toast-title",messageClass:"toast-message",target:"body",closeHtml:"<button>&times;</button>",newestOnTop:!0}}function i(a){o&&o(a)}function j(b){function c(b){return!a(":focus",j).length||b?j[f.hideMethod]({duration:f.hideDuration,easing:f.hideEasing,complete:function(){m(j),f.onHidden&&f.onHidden(),s.state="hidden",s.endTime=new Date,i(s)}}):void 0}function d(){(f.timeOut>0||f.extendedTimeOut>0)&&(h=setTimeout(c,f.extendedTimeOut))}function e(){clearTimeout(h),j.stop(!0,!0)[f.showMethod]({duration:f.showDuration,easing:f.showEasing})}var f=l(),g=b.iconClass||f.iconClass;"undefined"!=typeof b.optionsOverride&&(f=a.extend(f,b.optionsOverride),g=b.optionsOverride.iconClass||g),q++,n=k(f);var h=null,j=a("<div/>"),o=a("<div/>"),p=a("<div/>"),r=a(f.closeHtml),s={toastId:q,state:"visible",startTime:new Date,options:f,map:b};return b.iconClass&&j.addClass(f.toastClass).addClass(g),b.title&&(o.append(b.title).addClass(f.titleClass),j.append(o)),b.message&&(p.append(b.message).addClass(f.messageClass),j.append(p)),f.closeButton&&(r.addClass("toast-close-button"),j.prepend(r)),j.hide(),f.newestOnTop?n.prepend(j):n.append(j),j[f.showMethod]({duration:f.showDuration,easing:f.showEasing,complete:f.onShown}),f.timeOut>0&&(h=setTimeout(c,f.timeOut)),j.hover(e,d),!f.onclick&&f.tapToDismiss&&j.click(c),f.closeButton&&r&&r.click(function(a){a.stopPropagation(),c(!0)}),f.onclick&&j.click(function(){f.onclick(),c()}),i(s),f.debug&&console&&console.log(s),j}function k(b){return b||(b=l()),n=a("#"+b.containerId),n.length?n:(n=a("<div/>").attr("id",b.containerId).addClass(b.positionClass),n.appendTo(a(b.target)),n)}function l(){return a.extend({},h(),s.options)}function m(a){n||(n=k()),a.is(":visible")||(a.remove(),a=null,0===n.children().length&&n.remove())}var n,o,p="2.0.1",q=0,r={error:"error",info:"info",success:"success",warning:"warning"},s={clear:g,error:b,getContainer:k,info:c,options:{},subscribe:d,success:e,version:p,warning:f};return s}()})}("function"==typeof define&&define.amd?define:function(a,b){"undefined"!=typeof module&&module.exports?//Node
module.exports=b(require(a[0])):window.toastr=b(window.jQuery)}),angular.module("ui.bootstrap.position",[]).factory("$position",["$document","$window",function(a,b){function c(a,c){return a.currentStyle?a.currentStyle[c]:b.getComputedStyle?b.getComputedStyle(a)[c]:a.style[c]}/**
       * Checks if a given element is statically positioned
       * @param element - raw DOM element
       */
function d(a){return"static"===(c(a,"position")||"static")}/**
       * returns the closest, non-statically positioned parentOffset of a given element
       * @param element
       */
var e=function(b){for(var c=a[0],e=b.offsetParent||c;e&&e!==c&&d(e);)e=e.offsetParent;return e||c};return{/**
           * Provides read-only equivalent of jQuery's position function:
           * http://api.jquery.com/position/
           */
position:function(b){var c=this.offset(b),d={top:0,left:0},f=e(b[0]);f!=a[0]&&(d=this.offset(angular.element(f)),d.top+=f.clientTop-f.scrollTop,d.left+=f.clientLeft-f.scrollLeft);var g=b[0].getBoundingClientRect();return{width:g.width||b.prop("offsetWidth"),height:g.height||b.prop("offsetHeight"),top:c.top-d.top,left:c.left-d.left}},/**
           * Provides read-only equivalent of jQuery's offset function:
           * http://api.jquery.com/offset/
           */
offset:function(c){var d=c[0].getBoundingClientRect();return{width:d.width||c.prop("offsetWidth"),height:d.height||c.prop("offsetHeight"),top:d.top+(b.pageYOffset||a[0].body.scrollTop||a[0].documentElement.scrollTop),left:d.left+(b.pageXOffset||a[0].body.scrollLeft||a[0].documentElement.scrollLeft)}}}}]),angular.module("ui.bootstrap.bindHtml",[]).directive("bindHtmlUnsafe",function(){return function(a,b,c){b.addClass("ng-binding").data("$binding",c.bindHtmlUnsafe),a.$watch(c.bindHtmlUnsafe,function(a){b.html(a||"")})}}),angular.module("ui.bootstrap.typeahead",["ui.bootstrap.position","ui.bootstrap.bindHtml"]).factory("typeaheadParser",["$parse",function(a){//                      00000111000000000000022200000000000000003333333333333330000000000044000
var b=/^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;return{parse:function(c){var d=c.match(b);if(!d)throw new Error("Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_' but got '"+c+"'.");return{itemName:d[3],source:a(d[4]),viewMapper:a(d[2]||d[1]),modelMapper:a(d[1])}}}}]).directive("typeahead",["$compile","$parse","$q","$timeout","$document","$position","typeaheadParser",function(a,b,c,d,e,f,g){var h=[9,13,27,38,40];return{require:"ngModel",link:function(i,j,k,l){//SUPPORTED ATTRIBUTES (OPTIONS)
//minimal no of characters that needs to be entered before typeahead kicks-in
var m,n=i.$eval(k.typeaheadMinLength)||1,o=i.$eval(k.typeaheadWaitMs)||0,p=i.$eval(k.typeaheadEditable)!==!1,q=b(k.typeaheadLoading).assign||angular.noop,r=b(k.typeaheadOnSelect),s=k.typeaheadInputFormatter?b(k.typeaheadInputFormatter):void 0,t=b(k.ngModel).assign,u=g.parse(k.typeahead),v=angular.element("<div typeahead-popup></div>");v.attr({matches:"matches",active:"activeIdx",select:"select(activeIdx)",query:"query",position:"position"}),//custom item template
angular.isDefined(k.typeaheadTemplateUrl)&&v.attr("template-url",k.typeaheadTemplateUrl);//create a child scope for the typeahead directive so we are not polluting original scope
//with typeahead-specific data (matches, query etc.)
var w=i.$new();i.$on("$destroy",function(){w.$destroy()});var x=function(){w.matches=[],w.activeIdx=-1},y=function(a){var b={$viewValue:a};q(i,!0),c.when(u.source(i,b)).then(function(c){//it might happen that several async queries were in progress if a user were typing fast
//but we are interested only in responses that correspond to the current view value
if(a===l.$viewValue&&m){if(c.length>0){w.activeIdx=0,w.matches.length=0;//transform labels
for(var d=0;d<c.length;d++)b[u.itemName]=c[d],w.matches.push({label:u.viewMapper(w,b),model:c[d]});w.query=a,//position pop-up with matches - we need to re-calculate its position each time we are opening a window
//with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
//due to other elements being rendered
w.position=f.position(j),w.position.top=w.position.top+j.prop("offsetHeight")}else x();q(i,!1)}},function(){x(),q(i,!1)})};x(),//we need to propagate user's query so we can higlight matches
w.query=void 0;//Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
var z;//plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
//$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
l.$parsers.unshift(function(a){// Reset in case user had typed something previously.
return m=!0,a&&a.length>=n?o>0?(z&&d.cancel(z),z=d(function(){y(a)},o)):y(a):(q(i,!1),x()),p?a:a?void l.$setValidity("editable",!1):(l.$setValidity("editable",!0),a)}),l.$formatters.push(function(a){var b,c,d={};//it might happen that we don't have enough info to properly render input value
//we need to check for this situation and simply return model value if we can't apply custom formatting
return s?(d.$model=a,s(i,d)):(d[u.itemName]=a,b=u.viewMapper(i,d),d[u.itemName]=void 0,c=u.viewMapper(i,d),b!==c?b:a)}),w.select=function(a){//called from within the $digest() cycle
var b,c,d={};d[u.itemName]=c=w.matches[a].model,b=u.modelMapper(i,d),t(i,b),l.$setValidity("editable",!0),r(i,{$item:c,$model:b,$label:u.viewMapper(i,d)}),x(),//return focus to the input element if a mach was selected via a mouse click event
j[0].focus()},//bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
j.bind("keydown",function(a){//typeahead is open and an "interesting" key was pressed
//typeahead is open and an "interesting" key was pressed
return 0===w.matches.length||-1===h.indexOf(a.which)?void(13===a.which&&a.preventDefault()):(a.preventDefault(),void(40===a.which?(w.activeIdx=(w.activeIdx+1)%w.matches.length,w.$digest()):38===a.which?(w.activeIdx=(w.activeIdx?w.activeIdx:w.matches.length)-1,w.$digest()):13===a.which||9===a.which?w.$apply(function(){w.select(w.activeIdx)}):27===a.which&&(a.stopPropagation(),x(),w.$digest())))}),j.bind("blur",function(){m=!1});// Keep reference to click handler to unbind it.
var A=function(a){j[0]!==a.target&&(x(),w.$digest())};e.bind("click",A),i.$on("$destroy",function(){e.unbind("click",A)}),j.after(a(v)(w))}}}]).directive("typeaheadPopup",function(){return{restrict:"EA",scope:{matches:"=",query:"=",active:"=",position:"=",select:"&"},replace:!0,templateUrl:"/shared/typeahead-popup.html",link:function(a,b,c){a.templateUrl=c.templateUrl,a.isOpen=function(){return a.matches.length>0},a.isActive=function(b){return a.active==b},a.selectActive=function(b){a.active=b},a.selectMatch=function(b){a.select({activeIdx:b})},a.createNewOrg=function(a){alert(a+"3")}}}}).directive("typeaheadMatch",["$http","$templateCache","$compile","$parse",function(a,b,c,d){return{restrict:"EA",scope:{index:"=",match:"=",query:"="},link:function(e,f,g){var h=d(g.templateUrl)(e.$parent)||"/shared/typeahead-match.html";a.get(h,{cache:b}).success(function(a){f.replaceWith(c(a.trim())(e))})}}}]).filter("typeaheadHighlight",function(){function a(a){return a.replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")}return function(b,c){return c?b.replace(new RegExp(a(c),"gi"),"<strong>$&</strong>"):b}}),/*!
angular-xeditable - 0.1.7
Edit-in-place for angular.js
Build date: 2013-10-26 
*/
/*
angular-xeditable module
*/
angular.module("xeditable",[]).value("editableOptions",{theme:"default",//bs2, bs3,
buttons:"right",blur:"cancel"}),/*
Angular-ui bootstrap datepicker
http://angular-ui.github.io/bootstrap/#/datepicker
*/
angular.module("xeditable").directive("editableBsdate",["editableDirectiveFactory",function(a){return a({directiveName:"editableBsdate",inputTpl:'<input type="text">'})}]),/*
Angular-ui bootstrap editable timepicker
http://angular-ui.github.io/bootstrap/#/timepicker
*/
angular.module("xeditable").directive("editableBstime",["editableDirectiveFactory",function(a){return a({directiveName:"editableBstime",inputTpl:"<timepicker></timepicker>",render:function(){this.parent.render.call(this);// timepicker can't update model when ng-model set directly to it
// see: https://github.com/angular-ui/bootstrap/issues/1141
// so we wrap it into DIV
var a=angular.element('<div class="well well-small" style="display:inline-block;"></div>');// move ng-model to wrapping div
a.attr("ng-model",this.inputEl.attr("ng-model")),this.inputEl.removeAttr("ng-model"),// move ng-change to wrapping div
this.attrs.eNgChange&&(a.attr("ng-change",this.inputEl.attr("ng-change")),this.inputEl.removeAttr("ng-change")),// wrap
this.inputEl.wrap(a)}})}]),//checkbox
angular.module("xeditable").directive("editableCheckbox",["editableDirectiveFactory",function(a){return a({directiveName:"editableCheckbox",inputTpl:'<input type="checkbox">',render:function(){this.parent.render.call(this),this.attrs.eTitle&&(this.inputEl.wrap("<label></label>"),this.inputEl.after(angular.element("<span></span>").text(" "+this.attrs.eTitle)))},autosubmit:function(){var a=this;a.inputEl.bind("change",function(){setTimeout(function(){a.scope.$apply(function(){a.scope.$form.$submit()})},500)})}})}]),/*
Input types: text|email|tel|number|url|search|color|date|datetime|time|month|week
*/
function(){var a="text|email|tel|number|url|search|color|date|datetime|time|month|week".split("|");//todo: datalist
// generate directives
angular.forEach(a,function(a){var b="editable"+a.charAt(0).toUpperCase()+a.slice(1);angular.module("xeditable").directive(b,["editableDirectiveFactory",function(c){return c({directiveName:b,inputTpl:'<input type="'+a+'">'})}])}),//`range` is bit specific
angular.module("xeditable").directive("editableRange",["editableDirectiveFactory",function(a){return a({directiveName:"editableRange",inputTpl:'<input type="range" id="range" name="range">',render:function(){this.parent.render.call(this),this.inputEl.after("<output>{{$data}}</output>")}})}])}(),//select
angular.module("xeditable").directive("editableSelect",["editableDirectiveFactory",function(a){return a({directiveName:"editableSelect",inputTpl:"<select></select>",autosubmit:function(){var a=this;a.inputEl.bind("change",function(){a.scope.$apply(function(){a.scope.$form.$submit()})})}})}]),//textarea
angular.module("xeditable").directive("editableTextarea",["editableDirectiveFactory",function(a){return a({directiveName:"editableTextarea",inputTpl:"<textarea></textarea>",addListeners:function(){var a=this;a.parent.addListeners.call(a),// submit textarea by ctrl+enter even with buttons
a.single&&"no"!==a.buttons&&a.autosubmit()},autosubmit:function(){var a=this;a.inputEl.bind("keydown",function(b){(b.ctrlKey||b.metaKey)&&13===b.keyCode&&a.scope.$apply(function(){a.scope.$form.$submit()})})}})}]),/**
 * EditableController class. 
 * Attached to element with `editable-xxx` directive.
 *
 * @namespace editable-element
 */
/*
TODO: this file should be refactored to work more clear without closures!
*/
angular.module("xeditable").factory("editableController",["$q","$document","editableUtils","$rootScope",function(a,b,c,d){function e(a,b,d,e,g,h,i,j,k){var l,m,n=this;n.scope=a,n.elem=d,n.attrs=b,n.inputEl=null,n.editorEl=null,n.single=!0,n.error="",n.theme=g[h.theme]||g["default"],n.parent={},n.clicked=!1,//used to check in document click handler if control was clicked or not
//to be overwritten by directive
n.inputTpl="",n.directiveName="",//runtime (defaults)
n.single=null,/**
           * Attributes defined with `e-*` prefix automatically transfered from original element to
           * control.  
           * For example, if you set `<span editable-text="user.name" e-style="width: 100px"`>
           * then input will appear as `<input style="width: 100px">`.  
           * See [demo](#text-customize).
           * 
           * @var {any|attribute} e-*
           * @memberOf editable-element
           */
/**
           * Whether to show ok/cancel buttons. Values: `right|no`.
           * If set to `no` control automatically submitted when value changed.  
           * If control is part of form buttons will never be shown. 
           * 
           * @var {string|attribute} buttons
           * @memberOf editable-element
           */
n.buttons="right",/**
           * Action when control losses focus. Values: `cancel|submit|ignore`.
           * If control is part of form `blur` automatically set to `ignore`.  
           * 
           * @var {string|attribute} blur
           * @memberOf editable-element
           */
n.blur="ignore",// can be 'cancel|submit|ignore'
//init
n.init=function(c){/*
              if(!$attrs[directiveName] && !$attrs.eNgModel && ($attrs.eValue === undefined)) {
                throw 'You should provide value for `'+directiveName+'` or `e-value` in editable element!';
              }
              */
if(n.single=c,n.name=b.eName||b[n.directiveName],!b[n.directiveName])throw"You should provide value for `"+n.directiveName+"` in editable element!";l=e(b[n.directiveName]),// settings for single and non-single
n.single?(n.buttons=n.attrs.buttons||h.buttons,n.blur=n.attrs.blur||("no"===n.buttons?"cancel":h.blur)):(// hide buttons for non-single
n.buttons="no",n.blur="ignore"),//moved to show()
//self.render();
//if name defined --> watch changes and update $data in form
b.eName&&n.scope.$watch("$data",function(a){n.scope.$form.$data[b.eName]=a}),/**
               * Called when control is shown.  
               * See [demo](#select-remote).
               * 
               * @var {method|attribute} onshow
               * @memberOf editable-element
               */
b.onshow&&(n.onshow=function(){return n.catchError(e(b.onshow)(a))}),/**
               * Called when control is hidden after both save or cancel.  
               * 
               * @var {method|attribute} onhide
               * @memberOf editable-element
               */
b.onhide&&(n.onhide=function(){return e(b.onhide)(a)}),/**
               * Called when control is cancelled.  
               * 
               * @var {method|attribute} oncancel
               * @memberOf editable-element
               */
b.oncancel&&(n.oncancel=function(){return e(b.oncancel)(a)}),/**
               * Called during submit before value is saved to model.  
               * See [demo](#onbeforesave).
               * 
               * @var {method|attribute} onbeforesave
               * @memberOf editable-element
               */
b.onbeforesave&&(n.onbeforesave=function(){return n.catchError(e(b.onbeforesave)(a))}),/**
               * Called during submit after value is saved to model.  
               * See [demo](#onaftersave).
               * 
               * @var {method|attribute} onaftersave
               * @memberOf editable-element
               */
b.onaftersave&&(n.onaftersave=function(){return n.catchError(e(b.onaftersave)(a))}),// watch change of model to update editable element
// now only add/remove `editable-empty` class.
// Initially this method called with newVal = undefined, oldVal = undefined
// so no need initially call handleEmpty() explicitly
a.$parent.$watch(b[n.directiveName],function(){n.handleEmpty()})},n.render=function(){var a=n.theme;//build input
n.inputEl=angular.element(n.inputTpl),//build controls
n.controlsEl=angular.element(a.controlsTpl),n.controlsEl.append(n.inputEl),//build buttons
"no"!==n.buttons&&(n.buttonsEl=angular.element(a.buttonsTpl),n.submitEl=angular.element(a.submitTpl),n.cancelEl=angular.element(a.cancelTpl),n.buttonsEl.append(n.submitEl).append(n.cancelEl),n.controlsEl.append(n.buttonsEl),n.inputEl.addClass("editable-has-buttons")),//build error
n.errorEl=angular.element(a.errorTpl),n.controlsEl.append(n.errorEl),//build editor
n.editorEl=angular.element(n.single?a.formTpl:a.noformTpl),n.editorEl.append(n.controlsEl);// transfer `e-*|data-e-*|x-e-*` attributes
for(var d in b.$attr)if(!(d.length<=1)){var e=!1,f=d.substring(1,2);// if starts with `e` + uppercase letter
if("e"===d.substring(0,1)&&f===f.toUpperCase()&&(e=d.substring(1),"Form"!==e&&"NgSubmit"!==e))// exclude `form` and `ng-submit`, 
{// convert back to lowercase style
e=e.substring(0,1).toLowerCase()+c.camelToDash(e.substring(1));// workaround for attributes without value (e.g. `multiple = "multiple"`)
var g=""===b[d]?e:b[d];// set attributes to input
n.inputEl.attr(e,g)}}n.inputEl.addClass("editable-input"),n.inputEl.attr("ng-model","$data"),// add directiveName class to editor, e.g. `editable-text`
n.editorEl.addClass(c.camelToDash(n.directiveName)),n.single&&n.editorEl.attr("editable-form","$form"),//apply `postrender` method of theme
angular.isFunction(a.postrender)&&a.postrender.call(n)},//show
n.show=function(){// onshow
// set value. copy not needed.
// self.scope.$data = angular.copy(valueGetter($scope.$parent));
/*
              Originally render() was inside init() method, but some directives polluting editorEl,
              so it is broken on second openning.
              Cloning is not a solution as jqLite can not clone with event handler's.
              */
// insert into DOM
// compile (needed to attach ng-* events from markup)
// attach listeners (`escape`, autosubmit, etc)
// hide element
// add to internal list
// setTimeout needed to prevent closing right after opening (e.g. when trigger by button)
return n.scope.$data=l(a.$parent),n.render(),d.after(n.editorEl),j(n.editorEl)(a),n.addListeners(),d.addClass("editable-hide"),setTimeout(function(){-1===c.indexOf(f,n)&&f.push(n)},0),n.onshow()},//hide
n.hide=function(){// onhide
//console.log('editable hide', self.name);
// remove from internal list
return n.editorEl.remove(),d.removeClass("editable-hide"),c.arrayRemove(f,n),n.onhide()},// cancel
n.cancel=function(){// oncancel
n.oncancel()},/*
          Called after show to attach listeners
          */
n.addListeners=function(){// bind keyup for `escape`
n.inputEl.bind("keyup",function(a){if(n.single)switch(a.keyCode){// hide on `escape` press
case 27:n.scope.$form.$cancel()}}),// autosubmit when `no buttons`
n.single&&"no"===n.buttons&&n.autosubmit(),// click - mark element as clicked to exclude in document click handler
n.editorEl.bind("click",function(a){// ignore right/middle button click
1===a.which&&(n.clicked=!0)})},// setWaiting
n.setWaiting=function(a){a?(//participate in waiting only if not disabled
m=!n.inputEl.attr("disabled")&&!n.inputEl.attr("ng-disabled")&&!n.inputEl.attr("ng-enabled"),m&&(n.inputEl.attr("disabled","disabled"),n.buttonsEl&&n.buttonsEl.find("button").attr("disabled","disabled"))):m&&(n.inputEl.removeAttr("disabled"),n.buttonsEl&&n.buttonsEl.find("button").removeAttr("disabled"))},n.activate=function(){setTimeout(function(){n.inputEl[0].focus()},0)},n.setError=function(b){angular.isObject(b)||(a.$error=b,n.error=b)},/*
          Checks that result is string or promise returned string and shows it as error message
          Applied to onshow, onbeforesave, onaftersave
          */
n.catchError=function(a,b){//success and fail handlers are equal
//set result to string: to let form know that there was error
return angular.isObject(a)&&b!==!0?k.when(a).then(angular.bind(this,function(a){this.catchError(a,!0)}),angular.bind(this,function(a){this.catchError(a,!0)})):b&&angular.isObject(a)&&a.status&&200!==a.status&&a.data&&angular.isString(a.data)?(this.setError(a.data),a=a.data):angular.isString(a)&&this.setError(a),a},n.save=function(){l.assign(a.$parent,angular.copy(n.scope.$data))},/*
          attach/detach `editable-empty` class to element
          */
n.handleEmpty=function(){var b=l(a.$parent),c=null===b||void 0===b||""===b||angular.isArray(b)&&0===b.length;d.toggleClass("editable-empty",c)},/*
          Called when `buttons = "no"` to submit automatically
          */
n.autosubmit=angular.noop,n.onshow=angular.noop,n.onhide=angular.noop,n.oncancel=angular.noop,n.onbeforesave=angular.noop,n.onaftersave=angular.noop}// array of opened editable controls
var f=[];// bind click to body: cancel|submit editables
//EditableController function
return b.bind("click",function(a){// ignore right/middle button click
if(1===a.which){for(var b=[],c=[],e=0;e<f.length;e++)// exclude self
f[e].clicked?f[e].clicked=!1:("cancel"===f[e].blur&&b.push(f[e]),"submit"===f[e].blur&&c.push(f[e]));(b.length||c.length)&&d.$apply(function(){angular.forEach(b,function(a){a.scope.$form.$hide()}),angular.forEach(c,function(a){a.scope.$form.$submit()})})}}),e.$inject=["$scope","$attrs","$element","$parse","editableThemes","editableOptions","$rootScope","$compile","$q"],e}]),/*
editableFactory:
- attaches editableController to element
- used to generate editable directives

Depends on: editableController, editableFormFactory
*/
angular.module("xeditable").factory("editableDirectiveFactory",["$parse","$compile","editableThemes","$rootScope","$document","editableController","editableFormController",function(a,b,c,d,e,f,g){//directive object
return function(b){return{restrict:"A",scope:!0,require:[b.directiveName,"?^form"],controller:f,link:function(c,f,h,i){//editable controller
var j,k=i[0],l=!1;//if not inside form, but we have `e-form`:
//check if form exists somewhere in scope. If exists - bind, otherwise create.
if(i[1])j=i[1],l=!0;else if(h.eForm){var m=a(h.eForm)(c);if(m)//getter defined, form above
j=m,l=!0;else//form below or not exist: check document.forms
for(var n=0;n<e[0].forms.length;n++)if(e[0].forms[n].name===h.eForm){//form is below and not processed yet
j=null,l=!0;break}}// hasForm
if(/*
                if(hasForm && !attrs.eName) {
                  throw 'You should provide `e-name` for editable element inside form!';
                }
                */
//check for `editable-form` attr in form
/*
                if(eFormCtrl && ) {
                  throw 'You should provide `e-name` for editable element inside form!';
                }
                */
//store original props to `parent` before merge
angular.forEach(b,function(a,b){void 0!==k[b]&&(k.parent[b]=k[b])}),//merge overwrites to base editable controller
angular.extend(k,b),//init editable ctrl
k.init(!l),//publich editable controller as `$editable` to be referenced in html
c.$editable=k,// add `editable` class to element
f.addClass("editable"),l)if(j){if(c.$form=j,!c.$form.$addEditable)throw"Form with editable elements should have `editable-form` attribute.";c.$form.$addEditable(k)}else// future form (below): add editable controller to buffer and add to form later
d.$$editableBuffer=d.$$editableBuffer||{},d.$$editableBuffer[h.eForm]=d.$$editableBuffer[h.eForm]||[],d.$$editableBuffer[h.eForm].push(k),c.$form=null;else//create editableform controller
c.$form=g(),//add self to editable controller
c.$form.$addEditable(k),//elem.after(self.editorEl);
//console.log('w:', scope.$$watchers.length);
//$compile(eCtrl.editorEl)(scope);
//scope.$form.$addEditable(eCtrl);
//console.log('w:', scope.$$watchers.length);
//eCtrl.editorEl.remove();
//if `e-form` provided, publish local $form in scope
h.eForm&&(c.$parent[h.eForm]=c.$form),//bind click - if no external form defined
h.eForm||(f.addClass("editable-click"),f.bind("click",function(a){a.preventDefault(),a.editable=k,c.$apply(function(){c.$form.$show()})}))}}}}]),/*
Returns editableForm controller
*/
angular.module("xeditable").factory("editableFormController",["$parse","editablePromiseCollection",function(a,b){var c={$addEditable:function(a){//console.log('add editable', editable.elem, editable.elem.bind);
this.$editables.push(a),//'on' is not supported in angular 1.0.8
a.elem.bind("$destroy",angular.bind(this,this.$removeEditable,a)),//bind editable's local $form to self (if not bound yet, below form) 
a.scope.$form||(a.scope.$form=this),//if form already shown - call show() of new editable
this.$visible&&a.catchError(a.show())},$removeEditable:function(a){//arrayRemove
for(var b=0;b<this.$editables.length;b++)if(this.$editables[b]===a)return void this.$editables.splice(b,1)},/**
           * Shows form with editable controls.
           * 
           * @method $show()
           * @memberOf editable-form
           */
$show:function(){if(!this.$visible){this.$visible=!0;var a=b();//own show
a.when(this.$onshow()),//clear errors
this.$setError(null,""),//children show
angular.forEach(this.$editables,function(b){a.when(b.show())}),//wait promises and activate
a.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,this.$activate),onFalse:angular.bind(this,this.$activate),onString:angular.bind(this,this.$activate)})}},/**
           * Sets focus on form field specified by `name`.
           * 
           * @method $activate(name)
           * @param {string} name name of field
           * @memberOf editable-form
           */
$activate:function(a){var b;if(this.$editables.length){//activate by name
if(angular.isString(a))for(b=0;b<this.$editables.length;b++)if(this.$editables[b].name===a)return void this.$editables[b].activate();//try activate error field
for(b=0;b<this.$editables.length;b++)if(this.$editables[b].error)return void this.$editables[b].activate();//by default activate first field
this.$editables[0].activate()}},/**
           * Hides form with editable controls without saving.
           * 
           * @method $hide()
           * @memberOf editable-form
           */
$hide:function(){this.$visible&&(this.$visible=!1,// self hide
this.$onhide(),// children's hide
angular.forEach(this.$editables,function(a){a.hide()}))},/**
           * Triggers `oncancel` event and calls `$hide()`.
           * 
           * @method $cancel()
           * @memberOf editable-form
           */
$cancel:function(){this.$visible&&(// self cancel
this.$oncancel(),// children's cancel      
angular.forEach(this.$editables,function(a){a.cancel()}),// self hide
this.$hide())},$setWaiting:function(a){this.$waiting=!!a,// we can't just set $waiting variable and use it via ng-disabled in children
// because in editable-row form is not accessible
angular.forEach(this.$editables,function(b){b.setWaiting(!!a)})},/**
           * Shows error message for particular field.
           * 
           * @method $setError(name, msg)
           * @param {string} name name of field
           * @param {string} msg error message
           * @memberOf editable-form
           */
$setError:function(a,b){angular.forEach(this.$editables,function(c){a&&c.name!==a||c.setError(b)})},$submit:function(){//save
function a(a){var c=b();c.when(this.$onbeforesave()),c.then({onWait:angular.bind(this,this.$setWaiting),onTrue:a?angular.bind(this,this.$save):angular.bind(this,this.$hide),onFalse:angular.bind(this,this.$hide),onString:angular.bind(this,this.$activate)})}if(!this.$waiting){//clear errors
this.$setError(null,"");//children onbeforesave
var c=b();angular.forEach(this.$editables,function(a){c.when(a.onbeforesave())}),/*
              onbeforesave result:
              - true/undefined: save data and close form
              - false: close form without saving
              - string: keep form open and show error
              */
c.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,a,!0),onFalse:angular.bind(this,a,!1),onString:angular.bind(this,this.$activate)})}},$save:function(){// write model for each editable
angular.forEach(this.$editables,function(a){a.save()});//call onaftersave of self and children
var a=b();a.when(this.$onaftersave()),angular.forEach(this.$editables,function(b){a.when(b.onaftersave())}),/*
              onaftersave result:
              - true/undefined/false: just close form
              - string: keep form open and show error
              */
a.then({onWait:angular.bind(this,this.$setWaiting),onTrue:angular.bind(this,this.$hide),onFalse:angular.bind(this,this.$hide),onString:angular.bind(this,this.$activate)})},$onshow:angular.noop,$oncancel:angular.noop,$onhide:angular.noop,$onbeforesave:angular.noop,$onaftersave:angular.noop};return function(){return angular.extend({$editables:[],/**
               * Form visibility flag.
               * 
               * @var {bool} $visible
               * @memberOf editable-form
               */
$visible:!1,/**
               * Form waiting flag. It becomes `true` when form is loading or saving data.
               * 
               * @var {bool} $waiting
               * @memberOf editable-form
               */
$waiting:!1,$data:{}},c)}}]),/**
 * EditableForm directive. Should be defined in <form> containing editable controls.  
 * It add some usefull methods to form variable exposed to scope by `name="myform"` attribute.
 *
 * @namespace editable-form
 */
angular.module("xeditable").directive("editableForm",["$rootScope","$parse","editableFormController",function(a,b,c){return{restrict:"A",require:["form"],//require: ['form', 'editableForm'],
//controller: EditableFormController,
compile:function(){return{pre:function(b,d,e,f){var g,h=f[0];/*
                      Maybe it's better attach editable controller to form's controller not in pre()
                      but in controller itself. 
                      This allows to use ng-init already in <form> tag, otherwise we can't (in FF).
                      */
//if `editableForm` has value - publish smartly under this value
//this is required only for single editor form that is created and removed
e.editableForm?b[e.editableForm]&&b[e.editableForm].$show?(g=b[e.editableForm],angular.extend(h,g)):(g=c(),b[e.editableForm]=g,angular.extend(g,h)):(//just merge to form and publish if form has name
g=c(),angular.extend(h,g));//read editables from buffer (that appeared before FORM tag)
var i=a.$$editableBuffer,j=h.$name;j&&i&&i[j]&&(angular.forEach(i[j],function(a){g.$addEditable(a)}),delete i[j])},post:function(a,c,d,e){var f;f=d.editableForm&&a[d.editableForm]&&a[d.editableForm].$show?a[d.editableForm]:e[0],/**
                       * Called when form is shown.
                       * 
                       * @var {method|attribute} onshow 
                       * @memberOf editable-form
                       */
d.onshow&&(f.$onshow=angular.bind(f,b(d.onshow),a)),/**
                       * Called when form hides after both save or cancel.
                       * 
                       * @var {method|attribute} onhide 
                       * @memberOf editable-form
                       */
d.onhide&&(f.$onhide=angular.bind(f,b(d.onhide),a)),/**
                       * Called when form is cancelled.
                       * 
                       * @var {method|attribute} oncancel
                       * @memberOf editable-form
                       */
d.oncancel&&(f.$oncancel=angular.bind(f,b(d.oncancel),a)),/**
                       * Whether form initially rendered in shown state.
                       *
                       * @var {bool|attribute} shown
                       * @memberOf editable-form
                       */
d.shown&&b(d.shown)(a)&&f.$show(),// onbeforesave, onaftersave
d.ngSubmit||d.submit||(/**
                           * Called after all children `onbeforesave` callbacks but before saving form values
                           * to model.  
                           * If at least one children callback returns `non-string` - it will not not be called.  
                           * See [editable-form demo](#editable-form) for details.
                           * 
                           * @var {method|attribute} onbeforesave
                           * @memberOf editable-form
                           * 
                           */
d.onbeforesave&&(f.$onbeforesave=function(){return b(d.onbeforesave)(a,{$data:f.$data})}),/**
                           * Called when form values are saved to model.  
                           * See [editable-form demo](#editable-form) for details.
                           * 
                           * @var {method|attribute} onaftersave 
                           * @memberOf editable-form
                           * 
                           */
d.onaftersave&&(f.$onaftersave=function(){return b(d.onaftersave)(a,{$data:f.$data})}),c.bind("submit",function(b){b.preventDefault(),a.$apply(function(){f.$submit()})}))}}}}}]),/*
Helpers
*/
/*
Collect results of function calls. Shows waiting if there are promises. 
Finally, applies callbacks if:
- onTrue(): all results are true and all promises resolved to true
- onFalse(): at least one result is false or promise resolved to false
- onString(): at least one result is string or promise rejected or promise resolved to string
*/
angular.module("xeditable").factory("editablePromiseCollection",["$q",function(a){function b(){return{promises:[],hasFalse:!1,hasString:!1,when:function(b,c){if(b===!1)this.hasFalse=!0;else if(!c&&angular.isObject(b))this.promises.push(a.when(b));else{if(!angular.isString(b))//result === true || result === undefined || result === null
return;this.hasString=!0}},//callbacks: onTrue, onFalse, onString
then:function(b){function c(){h.hasString||h.hasFalse?!h.hasString&&h.hasFalse?e():f():d()}b=b||{};var d=b.onTrue||angular.noop,e=b.onFalse||angular.noop,f=b.onString||angular.noop,g=b.onWait||angular.noop,h=this;this.promises.length?(g(!0),a.all(this.promises).then(//all resolved       
function(a){g(!1),//check all results via same `when` method (without checking promises)
angular.forEach(a,function(a){h.when(a,!0)}),c()},//some rejected
function(){g(!1),f()})):c()}}}return b}]),angular.module("xeditable").factory("editableUtils",[function(){return{indexOf:function(a,b){if(a.indexOf)return a.indexOf(b);for(var c=0;c<a.length;c++)if(b===a[c])return c;return-1},arrayRemove:function(a,b){var c=this.indexOf(a,b);return c>=0&&a.splice(c,1),b},// copy from https://github.com/angular/angular.js/blob/master/src/Angular.js
camelToDash:function(a){var b=/[A-Z]/g;return a.replace(b,function(a,b){return(b?"-":"")+a.toLowerCase()})},dashToCamel:function(a){var b=/([\:\-\_]+(.))/g,c=/^moz([A-Z])/;return a.replace(b,function(a,b,c,d){return d?c.toUpperCase():c}).replace(c,"Moz$1")}}}]),/*
Editable themes:
- default
- bootstrap 2
- bootstrap 3

Note: in postrender() `this` is instance of editableController
*/
angular.module("xeditable").factory("editableThemes",function(){var a={//default
"default":{formTpl:'<form class="editable-wrap"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<span class="editable-controls"></span>',inputTpl:"",errorTpl:'<div class="editable-error" ng-show="$error">{{$error}}</div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit">save</button>',cancelTpl:'<button type="button" ng-click="$form.$cancel()">cancel</button>'},//bs2
bs2:{formTpl:'<form class="form-inline editable-wrap" role="form"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<div class="editable-controls controls control-group" ng-class="{\'error\': $error}"></div>',inputTpl:"",errorTpl:'<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit" class="btn btn-primary"><i class="fa fa-ok icon-white"></i></button>',cancelTpl:'<button type="button" class="btn" ng-click="$form.$cancel()"><i class="fa fa-remove"></i></button>'},//bs3
bs3:{formTpl:'<form class="form-inline editable-wrap" role="form"></form>',noformTpl:'<span class="editable-wrap"></span>',controlsTpl:'<div class="editable-controls form-group" ng-class="{\'has-error\': $error}"></div>',inputTpl:"",errorTpl:'<div class="editable-error help-block" ng-show="$error">{{$error}}</div>',buttonsTpl:'<span class="editable-buttons"></span>',submitTpl:'<button type="submit" class="btn btn-primary"><i class="fa fa-check"></i></button>',cancelTpl:'<button type="button" class="btn btn-default" ng-click="$form.$cancel()"><i class="fa fa-ban"></i></button>',//bs3 specific prop to change buttons class: btn-sm, btn-lg
buttonsClass:"",//bs3 specific prop to change standard inputs class: input-sm, input-lg
inputClass:"",postrender:function(){//apply `form-control` class to std inputs
switch(this.directiveName){case"editableText":case"editableSelect":case"editableTextarea":if(this.inputEl.addClass("form-control"),this.theme.inputClass){// don`t apply `input-sm` and `input-lg` to select multiple
// should be fixed in bs itself!
if(this.inputEl.attr("multiple")&&("input-sm"===this.theme.inputClass||"input-lg"===this.theme.inputClass))break;this.inputEl.addClass(this.theme.inputClass)}}//apply buttonsClass (bs3 specific!)
this.buttonsEl&&this.theme.buttonsClass&&this.buttonsEl.find("button").addClass(this.theme.buttonsClass)}}};return a}),angular.module("ui.bootstrap",["ui.bootstrap.tpls","ui.bootstrap.transition","ui.bootstrap.collapse","ui.bootstrap.accordion","ui.bootstrap.alert","ui.bootstrap.bindHtml","ui.bootstrap.buttons","ui.bootstrap.carousel","ui.bootstrap.position","ui.bootstrap.datepicker","ui.bootstrap.dropdownToggle","ui.bootstrap.modal","ui.bootstrap.pagination","ui.bootstrap.tooltip","ui.bootstrap.popover","ui.bootstrap.progressbar","ui.bootstrap.rating","ui.bootstrap.tabs","ui.bootstrap.timepicker","ui.bootstrap.typeahead"]),angular.module("ui.bootstrap.tpls",["template/accordion/accordion-group.html","template/accordion/accordion.html","template/alert/alert.html","template/carousel/carousel.html","template/carousel/slide.html","template/datepicker/datepicker.html","template/datepicker/popup.html","template/modal/backdrop.html","template/modal/window.html","template/pagination/pager.html","template/pagination/pagination.html","template/tooltip/tooltip-html-unsafe-popup.html","template/tooltip/tooltip-popup.html","template/popover/popover.html","template/progressbar/bar.html","template/progressbar/progress.html","template/progressbar/progressbar.html","template/rating/rating.html","template/tabs/tab.html","template/tabs/tabset.html","template/timepicker/timepicker.html","template/typeahead/typeahead-match.html","template/typeahead/typeahead-popup.html"]),angular.module("ui.bootstrap.transition",[]).factory("$transition",["$q","$timeout","$rootScope",function(a,b,c){function d(a){for(var b in a)if(void 0!==f.style[b])return a[b]}var e=function(d,f,g){g=g||{};var h=a.defer(),i=e[g.animation?"animationEndEventName":"transitionEndEventName"],j=function(){c.$apply(function(){d.unbind(i,j),h.resolve(d)})};// Wrap in a timeout to allow the browser time to update the DOM before the transition is to occur
// Add our custom cancel function to the promise that is returned
// We can call this if we are about to run a new transition, which we know will prevent this transition from ending,
// i.e. it will therefore never raise a transitionEnd event for that transition
return i&&d.bind(i,j),b(function(){angular.isString(f)?d.addClass(f):angular.isFunction(f)?f(d):angular.isObject(f)&&d.css(f),//If browser does not support transitions, instantly resolve
i||h.resolve(d)}),h.promise.cancel=function(){i&&d.unbind(i,j),h.reject("Transition cancelled")},h.promise},f=document.createElement("trans"),g={WebkitTransition:"webkitTransitionEnd",MozTransition:"transitionend",OTransition:"oTransitionEnd",transition:"transitionend"},h={WebkitTransition:"webkitAnimationEnd",MozTransition:"animationend",OTransition:"oAnimationEnd",transition:"animationend"};return e.transitionEndEventName=d(g),e.animationEndEventName=d(h),e}]),angular.module("ui.bootstrap.collapse",["ui.bootstrap.transition"]).directive("collapse",["$transition",function(a){return{link:function(b,c,d){function e(b){function d(){// Make sure it's this transition, otherwise, leave it alone.
j===e&&(j=void 0)}var e=a(c,b);return j&&j.cancel(),j=e,e.then(d,d),e}function f(){k?(k=!1,g()):(c.removeClass("collapse").addClass("collapsing"),e({height:c[0].scrollHeight+"px"}).then(g))}function g(){c.removeClass("collapsing"),c.addClass("collapse in"),c.css({height:"auto"})}function h(){if(k)k=!1,i(),c.css({height:0});else{// CSS transitions don't work with height: auto, so we have to manually change the height to a specific value
c.css({height:c[0].scrollHeight+"px"});//trigger reflow so a browser relaizes that height was updated from auto to a specific value
{c[0].offsetWidth}c.removeClass("collapse in").addClass("collapsing"),e({height:0}).then(i)}}function i(){c.removeClass("collapsing"),c.addClass("collapse")}var j,k=!0;b.$watch(d.collapse,function(a){a?h():f()})}}}]),angular.module("ui.bootstrap.accordion",["ui.bootstrap.collapse"]).constant("accordionConfig",{closeOthers:!0}).controller("AccordionController",["$scope","$attrs","accordionConfig",function(a,b,c){// This array keeps track of the accordion groups
this.groups=[],// Ensure that all the groups in this accordion are closed, unless close-others explicitly says not to
this.closeOthers=function(d){var e=angular.isDefined(b.closeOthers)?a.$eval(b.closeOthers):c.closeOthers;e&&angular.forEach(this.groups,function(a){a!==d&&(a.isOpen=!1)})},// This is called from the accordion-group directive to add itself to the accordion
this.addGroup=function(a){var b=this;this.groups.push(a),a.$on("$destroy",function(){b.removeGroup(a)})},// This is called from the accordion-group directive when to remove itself
this.removeGroup=function(a){var b=this.groups.indexOf(a);-1!==b&&this.groups.splice(this.groups.indexOf(a),1)}}]).directive("accordion",function(){return{restrict:"EA",controller:"AccordionController",transclude:!0,replace:!1,templateUrl:"template/accordion/accordion.html"}}).directive("accordionGroup",["$parse",function(a){return{require:"^accordion",// We need this directive to be inside an accordion
restrict:"EA",transclude:!0,// It transcludes the contents of the directive into the template
replace:!0,// The element containing the directive will be replaced with the template
templateUrl:"template/accordion/accordion-group.html",scope:{heading:"@"},// Create an isolated scope and interpolate the heading attribute onto this scope
controller:function(){this.setHeading=function(a){this.heading=a}},link:function(b,c,d,e){var f,g;e.addGroup(b),b.isOpen=!1,d.isOpen&&(f=a(d.isOpen),g=f.assign,b.$parent.$watch(f,function(a){b.isOpen=!!a})),b.$watch("isOpen",function(a){a&&e.closeOthers(b),g&&g(b.$parent,a)})}}}]).directive("accordionHeading",function(){return{restrict:"EA",transclude:!0,// Grab the contents to be used as the heading
template:"",// In effect remove this element!
replace:!0,require:"^accordionGroup",compile:function(a,b,c){return function(a,b,d,e){// Pass the heading to the accordion-group controller
// so that it can be transcluded into the right place in the template
// [The second parameter to transclude causes the elements to be cloned so that they work in ng-repeat]
e.setHeading(c(a,function(){}))}}}}).directive("accordionTransclude",function(){return{require:"^accordionGroup",link:function(a,b,c,d){a.$watch(function(){return d[c.accordionTransclude]},function(a){a&&(b.html(""),b.append(a))})}}}),angular.module("ui.bootstrap.alert",[]).controller("AlertController",["$scope","$attrs",function(a,b){a.closeable="close"in b}]).directive("alert",function(){return{restrict:"EA",controller:"AlertController",templateUrl:"template/alert/alert.html",transclude:!0,replace:!0,scope:{type:"=",close:"&"}}}),angular.module("ui.bootstrap.bindHtml",[]).directive("bindHtmlUnsafe",function(){return function(a,b,c){b.addClass("ng-binding").data("$binding",c.bindHtmlUnsafe),a.$watch(c.bindHtmlUnsafe,function(a){b.html(a||"")})}}),angular.module("ui.bootstrap.buttons",[]).constant("buttonConfig",{activeClass:"active",toggleEvent:"click"}).controller("ButtonsController",["buttonConfig",function(a){this.activeClass=a.activeClass||"active",this.toggleEvent=a.toggleEvent||"click"}]).directive("btnRadio",function(){return{require:["btnRadio","ngModel"],controller:"ButtonsController",link:function(a,b,c,d){var e=d[0],f=d[1];//model -> UI
f.$render=function(){b.toggleClass(e.activeClass,angular.equals(f.$modelValue,a.$eval(c.btnRadio)))},//ui->model
b.bind(e.toggleEvent,function(){b.hasClass(e.activeClass)||a.$apply(function(){f.$setViewValue(a.$eval(c.btnRadio)),f.$render()})})}}}).directive("btnCheckbox",function(){return{require:["btnCheckbox","ngModel"],controller:"ButtonsController",link:function(a,b,c,d){function e(){return g(c.btnCheckboxTrue,!0)}function f(){return g(c.btnCheckboxFalse,!1)}function g(b,c){var d=a.$eval(b);return angular.isDefined(d)?d:c}var h=d[0],i=d[1];//model -> UI
i.$render=function(){b.toggleClass(h.activeClass,angular.equals(i.$modelValue,e()))},//ui->model
b.bind(h.toggleEvent,function(){a.$apply(function(){i.$setViewValue(b.hasClass(h.activeClass)?f():e()),i.$render()})})}}}),/**
* @ngdoc overview
* @name ui.bootstrap.carousel
*
* @description
* AngularJS version of an image carousel.
*
*/
angular.module("ui.bootstrap.carousel",["ui.bootstrap.transition"]).controller("CarouselController",["$scope","$timeout","$transition","$q",function(a,b,c){function d(){e();var c=+a.interval;!isNaN(c)&&c>=0&&(g=b(f,c))}function e(){g&&(b.cancel(g),g=null)}function f(){h?(a.next(),d()):a.pause()}var g,h,i=this,j=i.slides=[],k=-1;i.currentSlide=null;var l=!1;/* direction: "prev" or "next" */
i.select=function(e,f){function g(){// Scope has been destroyed, stop here.
if(!l){//If we have a slide to transition from and we have a transition type and we're allowed, go
if(i.currentSlide&&angular.isString(f)&&!a.noTransition&&e.$element){//We shouldn't do class manip in here, but it's the same weird thing bootstrap does. need to fix sometime
e.$element.addClass(f);{e.$element[0].offsetWidth}//force reflow
//Set all other slides to stop doing their stuff for the new transition
angular.forEach(j,function(a){angular.extend(a,{direction:"",entering:!1,leaving:!1,active:!1})}),angular.extend(e,{direction:f,active:!0,entering:!0}),angular.extend(i.currentSlide||{},{direction:f,leaving:!0}),a.$currentTransition=c(e.$element,{}),//We have to create new pointers inside a closure since next & current will change
function(b,c){a.$currentTransition.then(function(){h(b,c)},function(){h(b,c)})}(e,i.currentSlide)}else h(e,i.currentSlide);i.currentSlide=e,k=m,//every time you change slides, reset the timer
d()}}function h(b,c){angular.extend(b,{direction:"",active:!0,leaving:!1,entering:!1}),angular.extend(c||{},{direction:"",active:!1,leaving:!1,entering:!1}),a.$currentTransition=null}var m=j.indexOf(e);//Decide direction if it's not given
void 0===f&&(f=m>k?"next":"prev"),e&&e!==i.currentSlide&&(a.$currentTransition?(a.$currentTransition.cancel(),//Timeout so ng-class in template has time to fix classes for finished slide
b(g)):g())},a.$on("$destroy",function(){l=!0}),/* Allow outside people to call indexOf on slides array */
i.indexOfSlide=function(a){return j.indexOf(a)},a.next=function(){var b=(k+1)%j.length;//Prevent this user-triggered transition from occurring if there is already one in progress
//Prevent this user-triggered transition from occurring if there is already one in progress
return a.$currentTransition?void 0:i.select(j[b],"next")},a.prev=function(){var b=0>k-1?j.length-1:k-1;//Prevent this user-triggered transition from occurring if there is already one in progress
//Prevent this user-triggered transition from occurring if there is already one in progress
return a.$currentTransition?void 0:i.select(j[b],"prev")},a.select=function(a){i.select(a)},a.isActive=function(a){return i.currentSlide===a},a.slides=function(){return j},a.$watch("interval",d),a.$on("$destroy",e),a.play=function(){h||(h=!0,d())},a.pause=function(){a.noPause||(h=!1,e())},i.addSlide=function(b,c){b.$element=c,j.push(b),//if this is the first slide or the slide is set to active, select it
1===j.length||b.active?(i.select(j[j.length-1]),1==j.length&&a.play()):b.active=!1},i.removeSlide=function(a){//get the index of the slide inside the carousel
var b=j.indexOf(a);j.splice(b,1),j.length>0&&a.active?i.select(b>=j.length?j[b-1]:j[b]):k>b&&k--}}]).directive("carousel",[function(){return{restrict:"EA",transclude:!0,replace:!0,controller:"CarouselController",require:"carousel",templateUrl:"template/carousel/carousel.html",scope:{interval:"=",noTransition:"=",noPause:"="}}}]).directive("slide",["$parse",function(a){return{require:"^carousel",restrict:"EA",transclude:!0,replace:!0,templateUrl:"template/carousel/slide.html",scope:{},link:function(b,c,d,e){//Set up optional 'active' = binding
if(d.active){var f=a(d.active),g=f.assign,h=b.active=f(b.$parent);b.$watch(function(){var a=f(b.$parent);// we are out of sync and need to copy
// parent changed and it has precedence
// if the parent can be assigned then do so
return a!==b.active&&(a!==h?h=b.active=a:g(b.$parent,a=h=b.active)),a})}e.addSlide(b,c),//when the scope is destroyed then remove the slide from the current slides array
b.$on("$destroy",function(){e.removeSlide(b)}),b.$watch("active",function(a){a&&e.select(b)})}}}]),angular.module("ui.bootstrap.position",[]).factory("$position",["$document","$window",function(a,b){function c(a,c){return a.currentStyle?a.currentStyle[c]:b.getComputedStyle?b.getComputedStyle(a)[c]:a.style[c]}/**
     * Checks if a given element is statically positioned
     * @param element - raw DOM element
     */
function d(a){return"static"===(c(a,"position")||"static")}/**
     * returns the closest, non-statically positioned parentOffset of a given element
     * @param element
     */
var e=function(b){for(var c=a[0],e=b.offsetParent||c;e&&e!==c&&d(e);)e=e.offsetParent;return e||c};return{/**
       * Provides read-only equivalent of jQuery's position function:
       * http://api.jquery.com/position/
       */
position:function(b){var c=this.offset(b),d={top:0,left:0},f=e(b[0]);f!=a[0]&&(d=this.offset(angular.element(f)),d.top+=f.clientTop-f.scrollTop,d.left+=f.clientLeft-f.scrollLeft);var g=b[0].getBoundingClientRect();return{width:g.width||b.prop("offsetWidth"),height:g.height||b.prop("offsetHeight"),top:c.top-d.top,left:c.left-d.left}},/**
       * Provides read-only equivalent of jQuery's offset function:
       * http://api.jquery.com/offset/
       */
offset:function(c){var d=c[0].getBoundingClientRect();return{width:d.width||c.prop("offsetWidth"),height:d.height||c.prop("offsetHeight"),top:d.top+(b.pageYOffset||a[0].body.scrollTop||a[0].documentElement.scrollTop),left:d.left+(b.pageXOffset||a[0].body.scrollLeft||a[0].documentElement.scrollLeft)}}}}]),angular.module("ui.bootstrap.datepicker",["ui.bootstrap.position"]).constant("datepickerConfig",{dayFormat:"dd",monthFormat:"MMMM",yearFormat:"yyyy",dayHeaderFormat:"EEE",dayTitleFormat:"MMMM yyyy",monthTitleFormat:"yyyy",showWeeks:!0,startingDay:0,yearRange:20,minDate:null,maxDate:null}).controller("DatepickerController",["$scope","$attrs","dateFilter","datepickerConfig",function(a,b,c,d){function e(b,c){return angular.isDefined(b)?a.$parent.$eval(b):c}function f(a,b){return new Date(a,b,0).getDate()}function g(a,b){for(var c=new Array(b),d=a,e=0;b>e;)c[e++]=new Date(d),d.setDate(d.getDate()+1);return c}function h(a,b,d,e){return{date:a,label:c(a,b),selected:!!d,secondary:!!e}}var i={day:e(b.dayFormat,d.dayFormat),month:e(b.monthFormat,d.monthFormat),year:e(b.yearFormat,d.yearFormat),dayHeader:e(b.dayHeaderFormat,d.dayHeaderFormat),dayTitle:e(b.dayTitleFormat,d.dayTitleFormat),monthTitle:e(b.monthTitleFormat,d.monthTitleFormat)},j=e(b.startingDay,d.startingDay),k=e(b.yearRange,d.yearRange);this.minDate=d.minDate?new Date(d.minDate):null,this.maxDate=d.maxDate?new Date(d.maxDate):null,this.modes=[{name:"day",getVisibleDates:function(a,b){var d=a.getFullYear(),e=a.getMonth(),k=new Date(d,e,1),l=j-k.getDay(),m=l>0?7-l:-l,n=new Date(k),o=0;m>0&&(n.setDate(-m+1),o+=m),o+=f(d,e+1),// Current
o+=(7-o%7)%7;for(var p=g(n,o),q=new Array(7),r=0;o>r;r++){var s=new Date(p[r]);p[r]=h(s,i.day,b&&b.getDate()===s.getDate()&&b.getMonth()===s.getMonth()&&b.getFullYear()===s.getFullYear(),s.getMonth()!==e)}for(var t=0;7>t;t++)q[t]=c(p[t].date,i.dayHeader);return{objects:p,title:c(a,i.dayTitle),labels:q}},compare:function(a,b){return new Date(a.getFullYear(),a.getMonth(),a.getDate())-new Date(b.getFullYear(),b.getMonth(),b.getDate())},split:7,step:{months:1}},{name:"month",getVisibleDates:function(a,b){for(var d=new Array(12),e=a.getFullYear(),f=0;12>f;f++){var g=new Date(e,f,1);d[f]=h(g,i.month,b&&b.getMonth()===f&&b.getFullYear()===e)}return{objects:d,title:c(a,i.monthTitle)}},compare:function(a,b){return new Date(a.getFullYear(),a.getMonth())-new Date(b.getFullYear(),b.getMonth())},split:3,step:{years:1}},{name:"year",getVisibleDates:function(a,b){for(var c=new Array(k),d=a.getFullYear(),e=parseInt((d-1)/k,10)*k+1,f=0;k>f;f++){var g=new Date(e+f,0,1);c[f]=h(g,i.year,b&&b.getFullYear()===g.getFullYear())}return{objects:c,title:[c[0].label,c[k-1].label].join(" - ")}},compare:function(a,b){return a.getFullYear()-b.getFullYear()},split:5,step:{years:k}}],this.isDisabled=function(b,c){var d=this.modes[c||0];return this.minDate&&d.compare(b,this.minDate)<0||this.maxDate&&d.compare(b,this.maxDate)>0||a.dateDisabled&&a.dateDisabled({date:b,mode:d.name})}}]).directive("datepicker",["dateFilter","$parse","datepickerConfig","$log",function(a,b,c,d){return{restrict:"EA",replace:!0,templateUrl:"template/datepicker/datepicker.html",scope:{dateDisabled:"&"},require:["datepicker","?^ngModel"],controller:"DatepickerController",link:function(a,e,f,g){function h(){a.showWeekNumbers=0===o&&q}// Split array into smaller arrays
function i(a,b){for(var c=[];a.length>0;)c.push(a.splice(0,b));return c}function j(b){var c=null,e=!0;n.$modelValue&&(c=new Date(n.$modelValue),isNaN(c)?(e=!1,d.error('Datepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')):b&&(p=c)),n.$setValidity("date",e);var f=m.modes[o],g=f.getVisibleDates(p,c);angular.forEach(g.objects,function(a){a.disabled=m.isDisabled(a.date,o)}),n.$setValidity("date-disabled",!c||!m.isDisabled(c)),a.rows=i(g.objects,f.split),a.labels=g.labels||[],a.title=g.title}function k(a){o=a,h(),j()}function l(a){var b=new Date(a);b.setDate(b.getDate()+4-(b.getDay()||7));// Thursday
var c=b.getTime();// Compare with Jan 1
return b.setMonth(0),b.setDate(1),Math.floor(Math.round((c-b)/864e5)/7)+1}var m=g[0],n=g[1];if(n){// Configuration parameters
var o=0,p=new Date,q=c.showWeeks;f.showWeeks?a.$parent.$watch(b(f.showWeeks),function(a){q=!!a,h()}):h(),f.min&&a.$parent.$watch(b(f.min),function(a){m.minDate=a?new Date(a):null,j()}),f.max&&a.$parent.$watch(b(f.max),function(a){m.maxDate=a?new Date(a):null,j()}),n.$render=function(){j(!0)},a.select=function(a){if(0===o){var b=n.$modelValue?new Date(n.$modelValue):new Date(0,0,0,0,0,0,0);b.setFullYear(a.getFullYear(),a.getMonth(),a.getDate()),n.$setViewValue(b),j(!0)}else p=a,k(o-1)},a.move=function(a){var b=m.modes[o].step;p.setMonth(p.getMonth()+a*(b.months||0)),p.setFullYear(p.getFullYear()+a*(b.years||0)),j()},a.toggleMode=function(){k((o+1)%m.modes.length)},a.getWeekNumber=function(b){return 0===o&&a.showWeekNumbers&&7===b.length?l(b[0].date):null}}}}}]).constant("datepickerPopupConfig",{dateFormat:"yyyy-MM-dd",currentText:"Today",toggleWeeksText:"Weeks",clearText:"Clear",closeText:"Done",closeOnDateSelection:!0,appendToBody:!1,showButtonBar:!0}).directive("datepickerPopup",["$compile","$parse","$document","$position","dateFilter","datepickerPopupConfig","datepickerConfig",function(a,b,c,d,e,f,g){return{restrict:"EA",require:"ngModel",link:function(h,i,j,k){// Initial state
function l(a){u?u(h,!!a):q.isOpen=!!a}// TODO: reverse from dateFilter string to Date object
function m(a){if(a){if(angular.isDate(a))return k.$setValidity("date",!0),a;if(angular.isString(a)){var b=new Date(a);return isNaN(b)?void k.$setValidity("date",!1):(k.$setValidity("date",!0),b)}return void k.$setValidity("date",!1)}return k.$setValidity("date",!0),null}function n(a,c,d){a&&(h.$watch(b(a),function(a){q[c]=a}),y.attr(d||c,c))}function o(){q.position=s?d.offset(i):d.position(i),q.position.top=q.position.top+i.prop("offsetHeight")}var// create a child scope so we are not polluting original one
p,q=h.$new(),r=angular.isDefined(j.closeOnDateSelection)?h.$eval(j.closeOnDateSelection):f.closeOnDateSelection,s=angular.isDefined(j.datepickerAppendToBody)?h.$eval(j.datepickerAppendToBody):f.appendToBody;j.$observe("datepickerPopup",function(a){p=a||f.dateFormat,k.$render()}),q.showButtonBar=angular.isDefined(j.showButtonBar)?h.$eval(j.showButtonBar):f.showButtonBar,h.$on("$destroy",function(){B.remove(),q.$destroy()}),j.$observe("currentText",function(a){q.currentText=angular.isDefined(a)?a:f.currentText}),j.$observe("toggleWeeksText",function(a){q.toggleWeeksText=angular.isDefined(a)?a:f.toggleWeeksText}),j.$observe("clearText",function(a){q.clearText=angular.isDefined(a)?a:f.clearText}),j.$observe("closeText",function(a){q.closeText=angular.isDefined(a)?a:f.closeText});var t,u;j.isOpen&&(t=b(j.isOpen),u=t.assign,h.$watch(t,function(a){q.isOpen=!!a})),q.isOpen=t?t(h):!1;var v=function(a){q.isOpen&&a.target!==i[0]&&q.$apply(function(){l(!1)})},w=function(){q.$apply(function(){l(!0)})},x=angular.element("<div datepicker-popup-wrap><div datepicker></div></div>");x.attr({"ng-model":"date","ng-change":"dateSelection()"});var y=angular.element(x.children()[0]);j.datepickerOptions&&y.attr(angular.extend({},h.$eval(j.datepickerOptions))),k.$parsers.unshift(m),// Inner change
q.dateSelection=function(a){angular.isDefined(a)&&(q.date=a),k.$setViewValue(q.date),k.$render(),r&&l(!1)},i.bind("input change keyup",function(){q.$apply(function(){q.date=k.$modelValue})}),// Outter change
k.$render=function(){var a=k.$viewValue?e(k.$viewValue,p):"";i.val(a),q.date=k.$modelValue},n(j.min,"min"),n(j.max,"max"),j.showWeeks?n(j.showWeeks,"showWeeks","show-weeks"):(q.showWeeks=g.showWeeks,y.attr("show-weeks","showWeeks")),j.dateDisabled&&y.attr("date-disabled",j.dateDisabled);var z=!1,A=!1;q.$watch("isOpen",function(a){a?(o(),c.bind("click",v),A&&i.unbind("focus",w),i[0].focus(),z=!0):(z&&c.unbind("click",v),i.bind("focus",w),A=!0),u&&u(h,a)}),q.today=function(){q.dateSelection(new Date)},q.clear=function(){q.dateSelection(null)};var B=a(x)(q);s?c.find("body").append(B):i.after(B)}}}]).directive("datepickerPopupWrap",function(){return{restrict:"EA",replace:!0,transclude:!0,templateUrl:"template/datepicker/popup.html",link:function(a,b){b.bind("click",function(a){a.preventDefault(),a.stopPropagation()})}}}),/*
 * dropdownToggle - Provides dropdown menu functionality in place of bootstrap js
 * @restrict class or attribute
 * @example:
   <li class="dropdown">
     <a class="dropdown-toggle">My Dropdown Menu</a>
     <ul class="dropdown-menu">
       <li ng-repeat="choice in dropChoices">
         <a ng-href="{{choice.href}}">{{choice.text}}</a>
       </li>
     </ul>
   </li>
 */
angular.module("ui.bootstrap.dropdownToggle",[]).directive("dropdownToggle",["$document","$location",function(a){var b=null,c=angular.noop;return{restrict:"CA",link:function(d,e){d.$watch("$location.path",function(){c()}),e.parent().bind("click",function(){c()}),e.bind("click",function(d){var f=e===b;d.preventDefault(),d.stopPropagation(),b&&c(),f||e.hasClass("disabled")||e.prop("disabled")||(e.parent().addClass("open"),b=e,c=function(d){d&&(d.preventDefault(),d.stopPropagation()),a.unbind("click",c),e.parent().removeClass("open"),c=angular.noop,b=null},a.bind("click",c))})}}}]),angular.module("ui.bootstrap.modal",[]).factory("$$stackedMap",function(){return{createNew:function(){var a=[];return{add:function(b,c){a.push({key:b,value:c})},get:function(b){for(var c=0;c<a.length;c++)if(b==a[c].key)return a[c]},keys:function(){for(var b=[],c=0;c<a.length;c++)b.push(a[c].key);return b},top:function(){return a[a.length-1]},remove:function(b){for(var c=-1,d=0;d<a.length;d++)if(b==a[d].key){c=d;break}return a.splice(c,1)[0]},removeTop:function(){return a.splice(a.length-1,1)[0]},length:function(){return a.length}}}}}).directive("modalBackdrop",["$timeout",function(a){return{restrict:"EA",replace:!0,templateUrl:"template/modal/backdrop.html",link:function(b){b.animate=!1,//trigger CSS transitions
a(function(){b.animate=!0})}}}]).directive("modalWindow",["$modalStack","$timeout",function(a,b){return{restrict:"EA",scope:{index:"@"},replace:!0,transclude:!0,templateUrl:"template/modal/window.html",link:function(c,d,e){c.windowClass=e.windowClass||"",b(function(){// trigger CSS transitions
c.animate=!0,// focus a freshly-opened modal
d[0].focus()}),c.close=function(b){var c=a.getTop();c&&c.value.backdrop&&"static"!=c.value.backdrop&&b.target===b.currentTarget&&(b.preventDefault(),b.stopPropagation(),a.dismiss(c.key,"backdrop click"))}}}}]).factory("$modalStack",["$document","$compile","$rootScope","$$stackedMap",function(a,b,c,d){function e(){for(var a=-1,b=k.keys(),c=0;c<b.length;c++)k.get(b[c]).value.backdrop&&(a=c);return a}function f(b){var c=a.find("body").eq(0),d=k.get(b).value;//clean up the stack
k.remove(b),//remove window DOM element
d.modalDomEl.remove(),c.toggleClass(i,k.length()>0),//remove backdrop if no longer needed
h&&-1==e()&&(h.remove(),h=void 0),//destroy scope
d.modalScope.$destroy()}var g,h,i="modal-open",j=c.$new(!0),k=d.createNew(),l={};return c.$watch(e,function(a){j.index=a}),a.bind("keydown",function(a){var b;27===a.which&&(b=k.top(),b&&b.value.keyboard&&c.$apply(function(){l.dismiss(b.key)}))}),l.open=function(c,d){k.add(c,{deferred:d.deferred,modalScope:d.scope,backdrop:d.backdrop,keyboard:d.keyboard});var f=a.find("body").eq(0);e()>=0&&!h&&(g=angular.element("<div modal-backdrop></div>"),h=b(g)(j),f.append(h));var l=angular.element("<div modal-window></div>");l.attr("window-class",d.windowClass),l.attr("index",k.length()-1),l.html(d.content);var m=b(l)(d.scope);k.top().value.modalDomEl=m,f.append(m),f.addClass(i)},l.close=function(a,b){var c=k.get(a).value;c&&(c.deferred.resolve(b),f(a))},l.dismiss=function(a,b){var c=k.get(a).value;c&&(c.deferred.reject(b),f(a))},l.getTop=function(){return k.top()},l}]).provider("$modal",function(){var a={options:{backdrop:!0,//can be also false or 'static'
keyboard:!0},$get:["$injector","$rootScope","$q","$http","$templateCache","$controller","$modalStack",function(b,c,d,e,f,g,h){function i(a){return a.template?d.when(a.template):e.get(a.templateUrl,{cache:f}).then(function(a){return a.data})}function j(a){var c=[];return angular.forEach(a,function(a){(angular.isFunction(a)||angular.isArray(a))&&c.push(d.when(b.invoke(a)))}),c}var k={};return k.open=function(b){var e=d.defer(),f=d.defer(),k={result:e.promise,opened:f.promise,close:function(a){h.close(k,a)},dismiss:function(a){h.dismiss(k,a)}};//verify options
if(//merge and clean up options
b=angular.extend({},a.options,b),b.resolve=b.resolve||{},!b.template&&!b.templateUrl)throw new Error("One of template or templateUrl options is required.");var l=d.all([i(b)].concat(j(b.resolve)));return l.then(function(a){var d=(b.scope||c).$new();d.$close=k.close,d.$dismiss=k.dismiss;var f,i={},j=1;//controllers
b.controller&&(i.$scope=d,i.$modalInstance=k,angular.forEach(b.resolve,function(b,c){i[c]=a[j++]}),f=g(b.controller,i)),h.open(k,{scope:d,deferred:e,content:a[0],backdrop:b.backdrop,keyboard:b.keyboard,windowClass:b.windowClass})},function(a){e.reject(a)}),l.then(function(){f.resolve(!0)},function(){f.reject(!1)}),k},k}]};return a}),angular.module("ui.bootstrap.pagination",[]).controller("PaginationController",["$scope","$attrs","$parse","$interpolate",function(a,b,c,d){var e=this,f=b.numPages?c(b.numPages).assign:angular.noop;this.init=function(d){b.itemsPerPage?a.$parent.$watch(c(b.itemsPerPage),function(b){e.itemsPerPage=parseInt(b,10),a.totalPages=e.calculateTotalPages()}):this.itemsPerPage=d},this.noPrevious=function(){return 1===this.page},this.noNext=function(){return this.page===a.totalPages},this.isActive=function(a){return this.page===a},this.calculateTotalPages=function(){var b=this.itemsPerPage<1?1:Math.ceil(a.totalItems/this.itemsPerPage);return Math.max(b||0,1)},this.getAttributeValue=function(b,c,e){return angular.isDefined(b)?e?d(b)(a.$parent):a.$parent.$eval(b):c},this.render=function(){this.page=parseInt(a.page,10)||1,this.page>0&&this.page<=a.totalPages&&(a.pages=this.getPages(this.page,a.totalPages))},a.selectPage=function(b){!e.isActive(b)&&b>0&&b<=a.totalPages&&(a.page=b,a.onSelectPage({page:b}))},a.$watch("page",function(){e.render()}),a.$watch("totalItems",function(){a.totalPages=e.calculateTotalPages()}),a.$watch("totalPages",function(b){f(a.$parent,b),// Readonly variable
e.page>b?a.selectPage(b):e.render()})}]).constant("paginationConfig",{itemsPerPage:10,boundaryLinks:!1,directionLinks:!0,firstText:"First",previousText:"Previous",nextText:"Next",lastText:"Last",rotate:!0}).directive("pagination",["$parse","paginationConfig",function(a,b){return{restrict:"EA",scope:{page:"=",totalItems:"=",onSelectPage:" &"},controller:"PaginationController",templateUrl:"template/pagination/pagination.html",replace:!0,link:function(c,d,e,f){// Create page object used in template
function g(a,b,c,d){return{number:a,text:b,active:c,disabled:d}}// Setup configuration parameters
var h,i=f.getAttributeValue(e.boundaryLinks,b.boundaryLinks),j=f.getAttributeValue(e.directionLinks,b.directionLinks),k=f.getAttributeValue(e.firstText,b.firstText,!0),l=f.getAttributeValue(e.previousText,b.previousText,!0),m=f.getAttributeValue(e.nextText,b.nextText,!0),n=f.getAttributeValue(e.lastText,b.lastText,!0),o=f.getAttributeValue(e.rotate,b.rotate);f.init(b.itemsPerPage),e.maxSize&&c.$parent.$watch(a(e.maxSize),function(a){h=parseInt(a,10),f.render()}),f.getPages=function(a,b){var c=[],d=1,e=b,p=angular.isDefined(h)&&b>h;// recompute if maxSize
p&&(o?(// Current page is displayed in the middle of the visible ones
d=Math.max(a-Math.floor(h/2),1),e=d+h-1,// Adjust if limit is exceeded
e>b&&(e=b,d=e-h+1)):(// Visible pages are paginated with maxSize
d=(Math.ceil(a/h)-1)*h+1,// Adjust last page if limit is exceeded
e=Math.min(d+h-1,b)));// Add page number links
for(var q=d;e>=q;q++){var r=g(q,q,f.isActive(q),!1);c.push(r)}// Add links to move between page sets
if(p&&!o){if(d>1){var s=g(d-1,"...",!1,!1);c.unshift(s)}if(b>e){var t=g(e+1,"...",!1,!1);c.push(t)}}// Add previous & next links
if(j){var u=g(a-1,l,!1,f.noPrevious());c.unshift(u);var v=g(a+1,m,!1,f.noNext());c.push(v)}// Add first & last links
if(i){var w=g(1,k,!1,f.noPrevious());c.unshift(w);var x=g(b,n,!1,f.noNext());c.push(x)}return c}}}}]).constant("pagerConfig",{itemsPerPage:10,previousText:" Previous",nextText:"Next ",align:!0}).directive("pager",["pagerConfig",function(a){return{restrict:"EA",scope:{page:"=",totalItems:"=",onSelectPage:" &"},controller:"PaginationController",templateUrl:"template/pagination/pager.html",replace:!0,link:function(b,c,d,e){// Create page object used in template
function f(a,b,c,d,e){return{number:a,text:b,disabled:c,previous:i&&d,next:i&&e}}// Setup configuration parameters
var g=e.getAttributeValue(d.previousText,a.previousText,!0),h=e.getAttributeValue(d.nextText,a.nextText,!0),i=e.getAttributeValue(d.align,a.align);e.init(a.itemsPerPage),e.getPages=function(a){return[f(a-1,g,e.noPrevious(),!0,!1),f(a+1,h,e.noNext(),!1,!0)]}}}}]),/**
 * The following features are still outstanding: animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html tooltips, and selector delegation.
 */
angular.module("ui.bootstrap.tooltip",["ui.bootstrap.position","ui.bootstrap.bindHtml"]).provider("$tooltip",function(){/**
   * This is a helper function for translating camel-case to snake-case.
   */
function a(a){var b=/[A-Z]/g,c="-";return a.replace(b,function(a,b){return(b?c:"")+a.toLowerCase()})}// The default options tooltip and popover.
var b={placement:"top",animation:!0,popupDelay:0},c={mouseenter:"mouseleave",click:"click",focus:"blur"},d={};/**
   * `options({})` allows global configuration of all tooltips in the
   * application.
   *
   *   var app = angular.module( 'App', ['ui.bootstrap.tooltip'], function( $tooltipProvider ) {
   *     // place tooltips left instead of top by default
   *     $tooltipProvider.options( { placement: 'left' } );
   *   });
   */
this.options=function(a){angular.extend(d,a)},/**
   * This allows you to extend the set of trigger mappings available. E.g.:
   *
   *   $tooltipProvider.setTriggers( 'openTrigger': 'closeTrigger' );
   */
this.setTriggers=function(a){angular.extend(c,a)},/**
   * Returns the actual instance of the $tooltip service.
   * TODO support multiple triggers
   */
this.$get=["$window","$compile","$timeout","$parse","$document","$position","$interpolate",function(e,f,g,h,i,j,k){return function(e,l,m){/**
       * Returns an object of show and hide triggers.
       *
       * If a trigger is supplied,
       * it is used to show the tooltip; otherwise, it will use the `trigger`
       * option passed to the `$tooltipProvider.options` method; else it will
       * default to the trigger supplied to this directive factory.
       *
       * The hide trigger is based on the show trigger. If the `trigger` option
       * was passed to the `$tooltipProvider.options` method, it will use the
       * mapped trigger from `triggerMap` or the passed trigger if the map is
       * undefined; otherwise, it uses the `triggerMap` value of the show
       * trigger; else it will just use the show trigger.
       */
function n(a){var b=a||o.trigger||m,d=c[b]||b;return{show:b,hide:d}}var o=angular.extend({},b,d),p=a(e),q=k.startSymbol(),r=k.endSymbol(),s="<div "+p+'-popup title="'+q+"tt_title"+r+'" content="'+q+"tt_content"+r+'" placement="'+q+"tt_placement"+r+'" animation="tt_animation" is-open="tt_isOpen"></div>';return{restrict:"EA",scope:!0,link:function(a,b,c){function d(){a.tt_isOpen?m():k()}// Show the tooltip with delay if specified, otherwise show it immediately
function k(){(!y||a.$eval(c[l+"Enable"]))&&(a.tt_popupDelay?(t=g(p,a.tt_popupDelay),t.then(function(a){a()})):a.$apply(p)())}function m(){a.$apply(function(){q()})}// Show the tooltip popup element.
function p(){// Don't show empty tooltips.
// Don't show empty tooltips.
// If there is a pending remove transition, we must cancel it, lest the
// tooltip be mysteriously removed.
// Set the initial positioning.
// Now we add it to the DOM because need some info about it. But it's not 
// visible yet anyway.
// And show the tooltip.
return a.tt_content?(r&&g.cancel(r),u.css({top:0,left:0,display:"block"}),v?i.find("body").append(u):b.after(u),z(),a.tt_isOpen=!0,z):angular.noop}// Hide the tooltip popup element.
function q(){// First things first: we don't show it anymore.
a.tt_isOpen=!1,//if tooltip is going to be shown after delay, we must cancel this
g.cancel(t),// And now we remove it from the DOM. However, if we have animation, we 
// need to wait for it to expire beforehand.
// FIXME: this is a placeholder for a port of the transitions library.
a.tt_animation?r=g(function(){u.remove()},500):u.remove()}var r,t,u=f(s)(a),v=angular.isDefined(o.appendToBody)?o.appendToBody:!1,w=n(void 0),x=!1,y=angular.isDefined(c[l+"Enable"]),z=function(){var c,d,e,f;// Calculate the tooltip's top and left coordinates to center it with
// this directive.
switch(// Get the position of the directive element.
c=v?j.offset(b):j.position(b),// Get the height and width of the tooltip so we can center it.
d=u.prop("offsetWidth"),e=u.prop("offsetHeight"),a.tt_placement){case"right":f={top:c.top+c.height/2-e/2,left:c.left+c.width};break;case"bottom":f={top:c.top+c.height,left:c.left+c.width/2-d/2};break;case"left":f={top:c.top+c.height/2-e/2,left:c.left-d};break;default:f={top:c.top-e,left:c.left+c.width/2-d/2}}f.top+="px",f.left+="px",// Now set the calculated positioning.
u.css(f)};// By default, the tooltip is not open.
// TODO add ability to start tooltip opened
a.tt_isOpen=!1,/**
           * Observe the relevant attributes.
           */
c.$observe(e,function(b){a.tt_content=b,!b&&a.tt_isOpen&&q()}),c.$observe(l+"Title",function(b){a.tt_title=b}),c.$observe(l+"Placement",function(b){a.tt_placement=angular.isDefined(b)?b:o.placement}),c.$observe(l+"PopupDelay",function(b){var c=parseInt(b,10);a.tt_popupDelay=isNaN(c)?o.popupDelay:c});var A=function(){x&&(b.unbind(w.show,k),b.unbind(w.hide,m))};c.$observe(l+"Trigger",function(a){A(),w=n(a),w.show===w.hide?b.bind(w.show,d):(b.bind(w.show,k),b.bind(w.hide,m)),x=!0});var B=a.$eval(c[l+"Animation"]);a.tt_animation=angular.isDefined(B)?!!B:o.animation,c.$observe(l+"AppendToBody",function(b){v=angular.isDefined(b)?h(b)(a):v}),// if a tooltip is attached to <body> we need to remove it on
// location change as its parent scope will probably not be destroyed
// by the change.
v&&a.$on("$locationChangeSuccess",function(){a.tt_isOpen&&q()}),// Make sure tooltip is destroyed and removed.
a.$on("$destroy",function(){g.cancel(r),g.cancel(t),A(),u.remove(),u.unbind(),u=null})}}}}]}).directive("tooltipPopup",function(){return{restrict:"EA",replace:!0,scope:{content:"@",placement:"@",animation:"&",isOpen:"&"},templateUrl:"template/tooltip/tooltip-popup.html"}}).directive("tooltip",["$tooltip",function(a){return a("tooltip","tooltip","mouseenter")}]).directive("tooltipHtmlUnsafePopup",function(){return{restrict:"EA",replace:!0,scope:{content:"@",placement:"@",animation:"&",isOpen:"&"},templateUrl:"template/tooltip/tooltip-html-unsafe-popup.html"}}).directive("tooltipHtmlUnsafe",["$tooltip",function(a){return a("tooltipHtmlUnsafe","tooltip","mouseenter")}]),/**
 * The following features are still outstanding: popup delay, animation as a
 * function, placement as a function, inside, support for more triggers than
 * just mouse enter/leave, html popovers, and selector delegatation.
 */
angular.module("ui.bootstrap.popover",["ui.bootstrap.tooltip"]).directive("popoverPopup",function(){return{restrict:"EA",replace:!0,scope:{title:"@",content:"@",placement:"@",animation:"&",isOpen:"&"},templateUrl:"template/popover/popover.html"}}).directive("popover",["$compile","$timeout","$parse","$window","$tooltip",function(a,b,c,d,e){return e("popover","popover","click")}]),angular.module("ui.bootstrap.progressbar",["ui.bootstrap.transition"]).constant("progressConfig",{animate:!0,max:100}).controller("ProgressController",["$scope","$attrs","progressConfig","$transition",function(a,b,c,d){var e=this,f=[],g=angular.isDefined(b.max)?a.$parent.$eval(b.max):c.max,h=angular.isDefined(b.animate)?a.$parent.$eval(b.animate):c.animate;this.addBar=function(a,b){var c=0,d=a.$parent.$index;angular.isDefined(d)&&f[d]&&(c=f[d].value),f.push(a),this.update(b,a.value,c),a.$watch("value",function(a,c){a!==c&&e.update(b,a,c)}),a.$on("$destroy",function(){e.removeBar(a)})},// Update bar element width
this.update=function(a,b,c){var e=this.getPercentage(b);h?(a.css("width",this.getPercentage(c)+"%"),d(a,{width:e+"%"})):a.css({transition:"none",width:e+"%"})},this.removeBar=function(a){f.splice(f.indexOf(a),1)},this.getPercentage=function(a){return Math.round(100*a/g)}}]).directive("progress",function(){return{restrict:"EA",replace:!0,transclude:!0,controller:"ProgressController",require:"progress",scope:{},template:'<div class="progress" ng-transclude></div>'}}).directive("bar",function(){return{restrict:"EA",replace:!0,transclude:!0,require:"^progress",scope:{value:"=",type:"@"},templateUrl:"template/progressbar/bar.html",link:function(a,b,c,d){d.addBar(a,b)}}}).directive("progressbar",function(){return{restrict:"EA",replace:!0,transclude:!0,controller:"ProgressController",scope:{value:"=",type:"@"},templateUrl:"template/progressbar/progressbar.html",link:function(a,b,c,d){d.addBar(a,angular.element(b.children()[0]))}}}),angular.module("ui.bootstrap.rating",[]).constant("ratingConfig",{max:5,stateOn:null,stateOff:null}).controller("RatingController",["$scope","$attrs","$parse","ratingConfig",function(a,b,c,d){this.maxRange=angular.isDefined(b.max)?a.$parent.$eval(b.max):d.max,this.stateOn=angular.isDefined(b.stateOn)?a.$parent.$eval(b.stateOn):d.stateOn,this.stateOff=angular.isDefined(b.stateOff)?a.$parent.$eval(b.stateOff):d.stateOff,this.createRateObjects=function(a){for(var b={stateOn:this.stateOn,stateOff:this.stateOff},c=0,d=a.length;d>c;c++)a[c]=angular.extend({index:c},b,a[c]);return a},// Get objects used in template
a.range=this.createRateObjects(angular.isDefined(b.ratingStates)?angular.copy(a.$parent.$eval(b.ratingStates)):new Array(this.maxRange)),a.rate=function(b){a.readonly||a.value===b||(a.value=b)},a.enter=function(b){a.readonly||(a.val=b),a.onHover({value:b})},a.reset=function(){a.val=angular.copy(a.value),a.onLeave()},a.$watch("value",function(b){a.val=b}),a.readonly=!1,b.readonly&&a.$parent.$watch(c(b.readonly),function(b){a.readonly=!!b})}]).directive("rating",function(){return{restrict:"EA",scope:{value:"=",onHover:"&",onLeave:"&"},controller:"RatingController",templateUrl:"template/rating/rating.html",replace:!0}}),/**
 * @ngdoc overview
 * @name ui.bootstrap.tabs
 *
 * @description
 * AngularJS version of the tabs directive.
 */
angular.module("ui.bootstrap.tabs",[]).controller("TabsetController",["$scope",function(a){var b=this,c=b.tabs=a.tabs=[];b.select=function(a){angular.forEach(c,function(a){a.active=!1}),a.active=!0},b.addTab=function(a){c.push(a),(1===c.length||a.active)&&b.select(a)},b.removeTab=function(a){var d=c.indexOf(a);//Select a new tab if the tab to be removed is selected
if(a.active&&c.length>1){//If this is the last tab, select the previous tab. else, the next tab.
var e=d==c.length-1?d-1:d+1;b.select(c[e])}c.splice(d,1)}}]).directive("tabset",function(){return{restrict:"EA",transclude:!0,replace:!0,scope:{},controller:"TabsetController",templateUrl:"template/tabs/tabset.html",link:function(a,b,c){a.vertical=angular.isDefined(c.vertical)?a.$parent.$eval(c.vertical):!1,a.justified=angular.isDefined(c.justified)?a.$parent.$eval(c.justified):!1,a.type=angular.isDefined(c.type)?a.$parent.$eval(c.type):"tabs"}}}).directive("tab",["$parse",function(a){return{require:"^tabset",restrict:"EA",replace:!0,templateUrl:"template/tabs/tab.html",transclude:!0,scope:{heading:"@",onSelect:"&select",//This callback is called in contentHeadingTransclude
//once it inserts the tab's content into the dom
onDeselect:"&deselect"},controller:function(){},compile:function(b,c,d){return function(b,c,e,f){var g,h;e.active?(g=a(e.active),h=g.assign,b.$parent.$watch(g,function(a,c){// Avoid re-initializing scope.active as it is already initialized
// below. (watcher is called async during init with value ===
// oldVal)
a!==c&&(b.active=!!a)}),b.active=g(b.$parent)):h=g=angular.noop,b.$watch("active",function(a){// Note this watcher also initializes and assigns scope.active to the
// attrs.active expression.
h(b.$parent,a),a?(f.select(b),b.onSelect()):b.onDeselect()}),b.disabled=!1,e.disabled&&b.$parent.$watch(a(e.disabled),function(a){b.disabled=!!a}),b.select=function(){b.disabled||(b.active=!0)},f.addTab(b),b.$on("$destroy",function(){f.removeTab(b)}),//We need to transclude later, once the content container is ready.
//when this link happens, we're inside a tab heading.
b.$transcludeFn=d}}}}]).directive("tabHeadingTransclude",[function(){return{restrict:"A",require:"^tab",link:function(a,b){a.$watch("headingElement",function(a){a&&(b.html(""),b.append(a))})}}}]).directive("tabContentTransclude",function(){function a(a){return a.tagName&&(a.hasAttribute("tab-heading")||a.hasAttribute("data-tab-heading")||"tab-heading"===a.tagName.toLowerCase()||"data-tab-heading"===a.tagName.toLowerCase())}return{restrict:"A",require:"^tabset",link:function(b,c,d){var e=b.$eval(d.tabContentTransclude);//Now our tab is ready to be transcluded: both the tab heading area
//and the tab content area are loaded.  Transclude 'em both.
e.$transcludeFn(e.$parent,function(b){angular.forEach(b,function(b){a(b)?//Let tabHeadingTransclude know.
e.headingElement=b:c.append(b)})})}}}),angular.module("ui.bootstrap.timepicker",[]).constant("timepickerConfig",{hourStep:1,minuteStep:1,showMeridian:!0,meridians:null,readonlyInput:!1,mousewheel:!0}).directive("timepicker",["$parse","$log","timepickerConfig","$locale",function(a,b,c,d){return{restrict:"EA",require:"?^ngModel",replace:!0,scope:{},templateUrl:"template/timepicker/timepicker.html",link:function(e,f,g,h){// Get scope.hours in 24H mode if valid
function i(){var a=parseInt(e.hours,10),b=e.showMeridian?a>0&&13>a:a>=0&&24>a;return b?(e.showMeridian&&(12===a&&(a=0),e.meridian===q[1]&&(a+=12)),a):void 0}function j(){var a=parseInt(e.minutes,10);return a>=0&&60>a?a:void 0}function k(a){return angular.isDefined(a)&&a.toString().length<2?"0"+a:a}// Call internally when we know that model is valid.
function l(a){m(),h.$setViewValue(new Date(p)),n(a)}function m(){h.$setValidity("time",!0),e.invalidHours=!1,e.invalidMinutes=!1}function n(a){var b=p.getHours(),c=p.getMinutes();e.showMeridian&&(b=0===b||12===b?12:b%12),e.hours="h"===a?b:k(b),e.minutes="m"===a?c:k(c),e.meridian=p.getHours()<12?q[0]:q[1]}function o(a){var b=new Date(p.getTime()+6e4*a);p.setHours(b.getHours(),b.getMinutes()),l()}if(h){var p=new Date,q=angular.isDefined(g.meridians)?e.$parent.$eval(g.meridians):c.meridians||d.DATETIME_FORMATS.AMPMS,r=c.hourStep;g.hourStep&&e.$parent.$watch(a(g.hourStep),function(a){r=parseInt(a,10)});var s=c.minuteStep;g.minuteStep&&e.$parent.$watch(a(g.minuteStep),function(a){s=parseInt(a,10)}),// 12H / 24H mode
e.showMeridian=c.showMeridian,g.showMeridian&&e.$parent.$watch(a(g.showMeridian),function(a){if(e.showMeridian=!!a,h.$error.time){// Evaluate from template
var b=i(),c=j();angular.isDefined(b)&&angular.isDefined(c)&&(p.setHours(b),l())}else n()});// Input elements
var t=f.find("input"),u=t.eq(0),v=t.eq(1),w=angular.isDefined(g.mousewheel)?e.$eval(g.mousewheel):c.mousewheel;if(w){var x=function(a){a.originalEvent&&(a=a.originalEvent);//pick correct delta variable depending on event
var b=a.wheelDelta?a.wheelDelta:-a.deltaY;return a.detail||b>0};u.bind("mousewheel wheel",function(a){e.$apply(x(a)?e.incrementHours():e.decrementHours()),a.preventDefault()}),v.bind("mousewheel wheel",function(a){e.$apply(x(a)?e.incrementMinutes():e.decrementMinutes()),a.preventDefault()})}if(e.readonlyInput=angular.isDefined(g.readonlyInput)?e.$eval(g.readonlyInput):c.readonlyInput,e.readonlyInput)e.updateHours=angular.noop,e.updateMinutes=angular.noop;else{var y=function(a,b){h.$setViewValue(null),h.$setValidity("time",!1),angular.isDefined(a)&&(e.invalidHours=a),angular.isDefined(b)&&(e.invalidMinutes=b)};e.updateHours=function(){var a=i();angular.isDefined(a)?(p.setHours(a),l("h")):y(!0)},u.bind("blur",function(){!e.validHours&&e.hours<10&&e.$apply(function(){e.hours=k(e.hours)})}),e.updateMinutes=function(){var a=j();angular.isDefined(a)?(p.setMinutes(a),l("m")):y(void 0,!0)},v.bind("blur",function(){!e.invalidMinutes&&e.minutes<10&&e.$apply(function(){e.minutes=k(e.minutes)})})}h.$render=function(){var a=h.$modelValue?new Date(h.$modelValue):null;isNaN(a)?(h.$setValidity("time",!1),b.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.')):(a&&(p=a),m(),n())},e.incrementHours=function(){o(60*r)},e.decrementHours=function(){o(60*-r)},e.incrementMinutes=function(){o(s)},e.decrementMinutes=function(){o(-s)},e.toggleMeridian=function(){o(720*(p.getHours()<12?1:-1))}}}}}]),angular.module("ui.bootstrap.typeahead",["ui.bootstrap.position","ui.bootstrap.bindHtml"]).factory("typeaheadParser",["$parse",function(a){//                      00000111000000000000022200000000000000003333333333333330000000000044000
var b=/^\s*(.*?)(?:\s+as\s+(.*?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+(.*)$/;return{parse:function(c){var d=c.match(b);if(!d)throw new Error("Expected typeahead specification in form of '_modelValue_ (as _label_)? for _item_ in _collection_' but got '"+c+"'.");return{itemName:d[3],source:a(d[4]),viewMapper:a(d[2]||d[1]),modelMapper:a(d[1])}}}}]).directive("typeahead",["$compile","$parse","$q","$timeout","$document","$position","typeaheadParser",function(a,b,c,d,e,f,g){var h=[9,13,27,38,40];return{require:"ngModel",link:function(i,j,k,l){//SUPPORTED ATTRIBUTES (OPTIONS)
//minimal no of characters that needs to be entered before typeahead kicks-in
var m,n=i.$eval(k.typeaheadMinLength)||1,o=i.$eval(k.typeaheadWaitMs)||0,p=i.$eval(k.typeaheadEditable)!==!1,q=b(k.typeaheadLoading).assign||angular.noop,r=b(k.typeaheadOnSelect),s=k.typeaheadInputFormatter?b(k.typeaheadInputFormatter):void 0,t=k.typeaheadAppendToBody?b(k.typeaheadAppendToBody):!1,u=b(k.ngModel).assign,v=g.parse(k.typeahead),w=angular.element("<div typeahead-popup></div>");w.attr({matches:"matches",active:"activeIdx",select:"select(activeIdx)",query:"query",position:"position"}),//custom item template
angular.isDefined(k.typeaheadTemplateUrl)&&w.attr("template-url",k.typeaheadTemplateUrl);//create a child scope for the typeahead directive so we are not polluting original scope
//with typeahead-specific data (matches, query etc.)
var x=i.$new();i.$on("$destroy",function(){x.$destroy()});var y=function(){x.matches=[],x.activeIdx=-1},z=function(a){var b={$viewValue:a};q(i,!0),c.when(v.source(i,b)).then(function(c){//it might happen that several async queries were in progress if a user were typing fast
//but we are interested only in responses that correspond to the current view value
if(a===l.$viewValue&&m){if(c.length>0){x.activeIdx=0,x.matches.length=0;//transform labels
for(var d=0;d<c.length;d++)b[v.itemName]=c[d],x.matches.push({label:v.viewMapper(x,b),model:c[d]});x.query=a,//position pop-up with matches - we need to re-calculate its position each time we are opening a window
//with matches as a pop-up might be absolute-positioned and position of an input might have changed on a page
//due to other elements being rendered
x.position=t?f.offset(j):f.position(j),x.position.top=x.position.top+j.prop("offsetHeight")}else y();q(i,!1)}},function(){y(),q(i,!1)})};y(),//we need to propagate user's query so we can higlight matches
x.query=void 0;//Declare the timeout promise var outside the function scope so that stacked calls can be cancelled later 
var A;//plug into $parsers pipeline to open a typeahead on view changes initiated from DOM
//$parsers kick-in on all the changes coming from the view as well as manually triggered by $setViewValue
l.$parsers.unshift(function(a){// Reset in case user had typed something previously.
return m=!0,a&&a.length>=n?o>0?(A&&d.cancel(A),A=d(function(){z(a)},o)):z(a):(q(i,!1),y()),p?a:a?void l.$setValidity("editable",!1):(l.$setValidity("editable",!0),a)}),l.$formatters.push(function(a){var b,c,d={};//it might happen that we don't have enough info to properly render input value
//we need to check for this situation and simply return model value if we can't apply custom formatting
return s?(d.$model=a,s(i,d)):(d[v.itemName]=a,b=v.viewMapper(i,d),d[v.itemName]=void 0,c=v.viewMapper(i,d),b!==c?b:a)}),x.select=function(a){//called from within the $digest() cycle
var b,c,d={};d[v.itemName]=c=x.matches[a].model,b=v.modelMapper(i,d),u(i,b),l.$setValidity("editable",!0),r(i,{$item:c,$model:b,$label:v.viewMapper(i,d)}),y(),//return focus to the input element if a mach was selected via a mouse click event
j[0].focus()},//bind keyboard events: arrows up(38) / down(40), enter(13) and tab(9), esc(27)
j.bind("keydown",function(a){//typeahead is open and an "interesting" key was pressed
0!==x.matches.length&&-1!==h.indexOf(a.which)&&(a.preventDefault(),40===a.which?(x.activeIdx=(x.activeIdx+1)%x.matches.length,x.$digest()):38===a.which?(x.activeIdx=(x.activeIdx?x.activeIdx:x.matches.length)-1,x.$digest()):13===a.which||9===a.which?x.$apply(function(){x.select(x.activeIdx)}):27===a.which&&(a.stopPropagation(),y(),x.$digest()))}),j.bind("blur",function(){m=!1});// Keep reference to click handler to unbind it.
var B=function(a){j[0]!==a.target&&(y(),x.$digest())};e.bind("click",B),i.$on("$destroy",function(){e.unbind("click",B)});var C=a(w)(x);t?e.find("body").append(C):j.after(C)}}}]).directive("typeaheadPopup",function(){return{restrict:"EA",scope:{matches:"=",query:"=",active:"=",position:"=",select:"&"},replace:!0,templateUrl:"template/typeahead/typeahead-popup.html",link:function(a,b,c){a.templateUrl=c.templateUrl,a.isOpen=function(){return a.matches.length>0},a.isActive=function(b){return a.active==b},a.selectActive=function(b){a.active=b},a.selectMatch=function(b){a.select({activeIdx:b})}}}}).directive("typeaheadMatch",["$http","$templateCache","$compile","$parse",function(a,b,c,d){return{restrict:"EA",scope:{index:"=",match:"=",query:"="},link:function(e,f,g){var h=d(g.templateUrl)(e.$parent)||"template/typeahead/typeahead-match.html";a.get(h,{cache:b}).success(function(a){f.replaceWith(c(a.trim())(e))})}}}]).filter("typeaheadHighlight",function(){function a(a){return a.replace(/([.?*+^$[\]\\(){}|-])/g,"\\$1")}return function(b,c){return c?b.replace(new RegExp(a(c),"gi"),"<strong>$&</strong>"):b}}),angular.module("template/accordion/accordion-group.html",[]).run(["$templateCache",function(a){a.put("template/accordion/accordion-group.html",'<div class="panel panel-default">\n  <div class="panel-heading">\n    <h4 class="panel-title">\n      <a class="accordion-toggle" ng-click="isOpen = !isOpen" accordion-transclude="heading">{{heading}}</a>\n    </h4>\n  </div>\n  <div class="panel-collapse" collapse="!isOpen">\n	  <div class="panel-body" ng-transclude></div>\n  </div>\n</div>')}]),angular.module("template/accordion/accordion.html",[]).run(["$templateCache",function(a){a.put("template/accordion/accordion.html",'<div class="panel-group" ng-transclude></div>')}]),angular.module("template/alert/alert.html",[]).run(["$templateCache",function(a){a.put("template/alert/alert.html","<div class='alert' ng-class='\"alert-\" + (type || \"warning\")'>\n    <button ng-show='closeable' type='button' class='close' ng-click='close()'>&times;</button>\n    <div ng-transclude></div>\n</div>\n")}]),angular.module("template/carousel/carousel.html",[]).run(["$templateCache",function(a){a.put("template/carousel/carousel.html",'<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel">\n    <ol class="carousel-indicators" ng-show="slides().length > 1">\n        <li ng-repeat="slide in slides()" ng-class="{active: isActive(slide)}" ng-click="select(slide)"></li>\n    </ol>\n    <div class="carousel-inner" ng-transclude></div>\n    <a class="left carousel-control" ng-click="prev()" ng-show="slides().length > 1"><span class="icon-prev"></span></a>\n    <a class="right carousel-control" ng-click="next()" ng-show="slides().length > 1"><span class="icon-next"></span></a>\n</div>\n')}]),angular.module("template/carousel/slide.html",[]).run(["$templateCache",function(a){a.put("template/carousel/slide.html","<div ng-class=\"{\n    'active': leaving || (active && !entering),\n    'prev': (next || active) && direction=='prev',\n    'next': (next || active) && direction=='next',\n    'right': direction=='prev',\n    'left': direction=='next'\n  }\" class=\"item text-center\" ng-transclude></div>\n")}]),angular.module("template/datepicker/datepicker.html",[]).run(["$templateCache",function(a){a.put("template/datepicker/datepicker.html",'<table>\n  <thead>\n    <tr>\n      <th><button type="button" class="btn btn-default btn-sm pull-left" ng-click="move(-1)"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n      <th colspan="{{rows[0].length - 2 + showWeekNumbers}}"><button type="button" class="btn btn-default btn-sm btn-block" ng-click="toggleMode()"><strong>{{title}}</strong></button></th>\n      <th><button type="button" class="btn btn-default btn-sm pull-right" ng-click="move(1)"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n    </tr>\n    <tr ng-show="labels.length > 0" class="h6">\n      <th ng-show="showWeekNumbers" class="text-center">#</th>\n      <th ng-repeat="label in labels" class="text-center">{{label}}</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr ng-repeat="row in rows">\n      <td ng-show="showWeekNumbers" class="text-center"><em>{{ getWeekNumber(row) }}</em></td>\n      <td ng-repeat="dt in row" class="text-center">\n        <button type="button" style="width:100%;" class="btn btn-default btn-sm" ng-class="{\'btn-info\': dt.selected}" ng-click="select(dt.date)" ng-disabled="dt.disabled"><span ng-class="{\'text-muted\': dt.secondary}">{{dt.label}}</span></button>\n      </td>\n    </tr>\n  </tbody>\n</table>\n')}]),angular.module("template/datepicker/popup.html",[]).run(["$templateCache",function(a){a.put("template/datepicker/popup.html","<ul class=\"dropdown-menu\" ng-style=\"{display: (isOpen && 'block') || 'none', top: position.top+'px', left: position.left+'px'}\">\n	<li ng-transclude></li>\n"+'	<li ng-show="showButtonBar" style="padding:10px 9px 2px">\n		<span class="btn-group">\n			<button type="button" class="btn btn-sm btn-info" ng-click="today()">{{currentText}}</button>\n			<button type="button" class="btn btn-sm btn-default" ng-click="showWeeks = ! showWeeks" ng-class="{active: showWeeks}">{{toggleWeeksText}}</button>\n			<button type="button" class="btn btn-sm btn-danger" ng-click="clear()">{{clearText}}</button>\n		</span>\n		<button type="button" class="btn btn-sm btn-success pull-right" ng-click="isOpen = false">{{closeText}}</button>\n	</li>\n</ul>\n')}]),angular.module("template/modal/backdrop.html",[]).run(["$templateCache",function(a){a.put("template/modal/backdrop.html",'<div class="modal-backdrop fade" ng-class="{in: animate}" ng-style="{\'z-index\': 1040 + index*10}"></div>')}]),angular.module("template/modal/window.html",[]).run(["$templateCache",function(a){a.put("template/modal/window.html",'<div tabindex="-1" class="modal fade {{ windowClass }}" ng-class="{in: animate}" ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}" ng-click="close($event)">\n    <div class="modal-dialog"><div class="modal-content" ng-transclude></div></div>\n</div>')}]),angular.module("template/pagination/pager.html",[]).run(["$templateCache",function(a){a.put("template/pagination/pager.html",'<ul class="pager">\n  <li ng-repeat="page in pages" ng-class="{disabled: page.disabled, previous: page.previous, next: page.next}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n</ul>')}]),angular.module("template/pagination/pagination.html",[]).run(["$templateCache",function(a){a.put("template/pagination/pagination.html",'<ul class="pagination">\n  <li ng-repeat="page in pages" ng-class="{active: page.active, disabled: page.disabled}"><a ng-click="selectPage(page.number)">{{page.text}}</a></li>\n</ul>')}]),angular.module("template/tooltip/tooltip-html-unsafe-popup.html",[]).run(["$templateCache",function(a){a.put("template/tooltip/tooltip-html-unsafe-popup.html",'<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" bind-html-unsafe="content"></div>\n</div>\n')}]),angular.module("template/tooltip/tooltip-popup.html",[]).run(["$templateCache",function(a){a.put("template/tooltip/tooltip-popup.html",'<div class="tooltip {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="tooltip-arrow"></div>\n  <div class="tooltip-inner" ng-bind="content"></div>\n</div>\n')}]),angular.module("template/popover/popover.html",[]).run(["$templateCache",function(a){a.put("template/popover/popover.html",'<div class="popover {{placement}}" ng-class="{ in: isOpen(), fade: animation() }">\n  <div class="arrow"></div>\n\n  <div class="popover-inner">\n      <h3 class="popover-title" ng-bind="title" ng-show="title"></h3>\n      <div class="popover-content" ng-bind="content"></div>\n  </div>\n</div>\n')}]),angular.module("template/progressbar/bar.html",[]).run(["$templateCache",function(a){a.put("template/progressbar/bar.html",'<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div>')}]),angular.module("template/progressbar/progress.html",[]).run(["$templateCache",function(a){a.put("template/progressbar/progress.html",'<div class="progress" ng-transclude></div>')}]),angular.module("template/progressbar/progressbar.html",[]).run(["$templateCache",function(a){a.put("template/progressbar/progressbar.html",'<div class="progress"><div class="progress-bar" ng-class="type && \'progress-bar-\' + type" ng-transclude></div></div>')}]),angular.module("template/rating/rating.html",[]).run(["$templateCache",function(a){a.put("template/rating/rating.html",'<span ng-mouseleave="reset()">\n    <i ng-repeat="r in range" ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < val && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')"></i>\n</span>')}]),angular.module("template/tabs/tab.html",[]).run(["$templateCache",function(a){a.put("template/tabs/tab.html",'<li ng-class="{active: active, disabled: disabled}">\n  <a ng-click="select()" tab-heading-transclude>{{heading}}</a>\n</li>\n')}]),angular.module("template/tabs/tabset-titles.html",[]).run(["$templateCache",function(a){a.put("template/tabs/tabset-titles.html","<ul class=\"nav {{type && 'nav-' + type}}\" ng-class=\"{'nav-stacked': vertical}\">\n</ul>\n")}]),angular.module("template/tabs/tabset.html",[]).run(["$templateCache",function(a){a.put("template/tabs/tabset.html",'\n<div class="tabbable">\n  <ul class="nav {{type && \'nav-\' + type}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n  <div class="tab-content">\n    <div class="tab-pane" \n         ng-repeat="tab in tabs" \n         ng-class="{active: tab.active}"\n         tab-content-transclude="tab">\n    </div>\n  </div>\n</div>\n')}]),angular.module("template/timepicker/timepicker.html",[]).run(["$templateCache",function(a){a.put("template/timepicker/timepicker.html",'<table>\n	<tbody>\n		<tr class="text-center">\n			<td><a ng-click="incrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n			<td>&nbsp;</td>\n			<td><a ng-click="incrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n			<td ng-show="showMeridian"></td>\n		</tr>\n		<tr>\n			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidHours}">\n				<input type="text" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-mousewheel="incrementHours()" ng-readonly="readonlyInput" maxlength="2">\n			</td>\n			<td>:</td>\n			<td style="width:50px;" class="form-group" ng-class="{\'has-error\': invalidMinutes}">\n				<input type="text" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2">\n			</td>\n			<td ng-show="showMeridian"><button class="btn btn-default text-center" ng-click="toggleMeridian()">{{meridian}}</button></td>\n		</tr>\n		<tr class="text-center">\n			<td><a ng-click="decrementHours()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n			<td>&nbsp;</td>\n			<td><a ng-click="decrementMinutes()" class="btn btn-link"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n			<td ng-show="showMeridian"></td>\n		</tr>\n	</tbody>\n</table>\n')}]),angular.module("template/typeahead/typeahead-match.html",[]).run(["$templateCache",function(a){a.put("template/typeahead/typeahead-match.html",'<a tabindex="-1" bind-html-unsafe="match.label | typeaheadHighlight:query"></a>')}]),angular.module("template/typeahead/typeahead-popup.html",[]).run(["$templateCache",function(a){a.put("template/typeahead/typeahead-popup.html","<ul class=\"dropdown-menu\" ng-style=\"{display: isOpen()&&'block' || 'none', top: position.top+'px', left: position.left+'px'}\">\n"+'    <li ng-repeat="match in matches" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index)">\n        <div typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n    </li>\n</ul>')}]);
//# sourceMappingURL=web-app/assets/sources.min.js.map